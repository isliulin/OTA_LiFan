	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v4.3r1 Build 759 SN 00641831"
	.compiler_invocation	"ctc -f cc9136a -c99 --dep-file=.cstart.o.d -D__CPU__=tc1782 -D__CPU_TC1782__ --core=tc1.3.1 -F -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Communication_Files\\CanDrv -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Communication_Files\\Com -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Communication_Files\\Com\\Can_Input -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Communication_Files\\Com\\Can_Output -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Communication_Files\\Uds\\Dcm -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Communication_Files\\Uds\\Dem -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Communication_Files\\Uds\\Tp -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Communication_Files\\Uds\\User -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Complex_Files -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Initiate_Files -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Nvm_Files\\FlsDrv -ID:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Stand_Header -g2 --make-target=cstart.o -t4 --language=-gcc,-volatile,+strings --default-near-size=0 -O2 --default-a1-size=0 --default-a0-size=0 --source --align=0 --compact-max-size=200 --switch=auto -o cstart.src ..\\cstart.c"
	.compiler_name		"ctc"
	.name	"cstart"

	
$TC131
	
	.sdecl	'.text.cstart._endinit_clear',code,cluster('_endinit_clear')
	.sect	'.text.cstart._endinit_clear'
	.align	2
	
	.global	_endinit_clear

; ..\cstart.c	     1  /**************************************************************************
; ..\cstart.c	     2  **                                                                        *
; ..\cstart.c	     3  **  FILE        :  cstart.c                                               *
; ..\cstart.c	     4  **                                                                        *
; ..\cstart.c	     5  **  DESCRIPTION :                                                         *
; ..\cstart.c	     6  **      The system startup code initializes the processor's registers     *
; ..\cstart.c	     7  **      and the application C variables.                                  *
; ..\cstart.c	     8  **                                                                        *
; ..\cstart.c	     9  **  Copyright 1996-2013 Altium BV                                         *
; ..\cstart.c	    10  **                                                                        *
; ..\cstart.c	    11  **************************************************************************/
; ..\cstart.c	    12  
; ..\cstart.c	    13  #include "cstart.h"                             /* include configuration */
; ..\cstart.c	    14  
; ..\cstart.c	    15  #include <stdlib.h>
; ..\cstart.c	    16  #include <stdbool.h>
; ..\cstart.c	    17  
; ..\cstart.c	    18  #ifdef __CPU__
; ..\cstart.c	    19  #include __SFRFILE__(__CPU__)
; ..\cstart.c	    20  #endif
; ..\cstart.c	    21  
; ..\cstart.c	    22  #pragma weak   exit
; ..\cstart.c	    23  #pragma extern _Exit
; ..\cstart.c	    24  #pragma profiling off                           /* prevent profiling information on cstart */
; ..\cstart.c	    25  #pragma tradeoff 4                              /* preset tradeoff level (for size) */
; ..\cstart.c	    26  #pragma runtime BCM                             /* disable runtime error checking for cstart */
; ..\cstart.c	    27  #pragma nomisrac                                /* disable MISRA-C checking */
; ..\cstart.c	    28  #pragma noclear                                 /* bss clearing not before cinit */
; ..\cstart.c	    29  #pragma immediate_in_code                       /* no external ROM access before bus configuration */
; ..\cstart.c	    30  
; ..\cstart.c	    31  #if __USE_ARGC_ARGV
; ..\cstart.c	    32  static char argcv[__ARGCV_BUFSIZE];
; ..\cstart.c	    33  extern int _argcv( const char *, size_t );
; ..\cstart.c	    34  #endif
; ..\cstart.c	    35  
; ..\cstart.c	    36  /* linker definitions */
; ..\cstart.c	    37  extern __far void _lc_ue_ustack[];      /* user stack end */
; ..\cstart.c	    38  extern __far void _lc_ue_istack[];      /* interrupt stack end */
; ..\cstart.c	    39  extern __far void _lc_u_int_tab[];      /* interrupt table */
; ..\cstart.c	    40  extern __far void _lc_u_trap_tab[];     /* trap table */
; ..\cstart.c	    41  extern __far void _SMALL_DATA_[];       /* centre of A0 addressable area */
; ..\cstart.c	    42  extern __far void _LITERAL_DATA_[];     /* centre of A1 addressable area */
; ..\cstart.c	    43  extern __far void _A8_DATA_[];          /* centre of A8 addressable area */
; ..\cstart.c	    44  extern __far void _A9_DATA_[];          /* centre of A9 addressable area */
; ..\cstart.c	    45  
; ..\cstart.c	    46  /* external functions */
; ..\cstart.c	    47  #if __C_INIT
; ..\cstart.c	    48  extern void _c_init(void);              /* C initialization function */
; ..\cstart.c	    49  #endif
; ..\cstart.c	    50  #ifdef __CALL_INIT
; ..\cstart.c	    51  extern void _call_init(void);           /* call a user function before main() */
; ..\cstart.c	    52  #endif
; ..\cstart.c	    53  #ifdef _CALL_ENDINIT
; ..\cstart.c	    54  extern void _endinit(void);             /* call a user function with protection switched off */
; ..\cstart.c	    55  #endif
; ..\cstart.c	    56  
; ..\cstart.c	    57  /* local functions */
; ..\cstart.c	    58  static void __noinline__ __noreturn__ __jump__ __init_sp( void );
; ..\cstart.c	    59  static void __noinline__ __noreturn__ __jump__ _start( void );
; ..\cstart.c	    60  
; ..\cstart.c	    61  /* library references */
; ..\cstart.c	    62  #pragma extern main
; ..\cstart.c	    63  extern int main( int argc, char *argv[] );
; ..\cstart.c	    64  
; ..\cstart.c	    65  /* endinit types */
; ..\cstart.c	    66  typedef enum
; ..\cstart.c	    67  {
; ..\cstart.c	    68          _ENDINIT_DISABLE,
; ..\cstart.c	    69          _ENDINIT_ENABLE
; ..\cstart.c	    70  }       _endinit_t;
; ..\cstart.c	    71  static void inline endinit_set(_endinit_t endinit_value);
; ..\cstart.c	    72  
; ..\cstart.c	    73  /* external interface to endinit_set */
; ..\cstart.c	    74  extern void _endinit_clear(void) { endinit_set(_ENDINIT_DISABLE); }
; Function _endinit_clear
.L6:
_endinit_clear:	.type	func

; ..\cstart.c	    75  extern void _endinit_set  (void) { endinit_set(_ENDINIT_ENABLE); }
; ..\cstart.c	    76  
; ..\cstart.c	    77  #if __PROF_ENABLE__
; ..\cstart.c	    78  extern void __prof_init( void );
; ..\cstart.c	    79  #endif
; ..\cstart.c	    80  
; ..\cstart.c	    81  #if __CLOCKS_PER_SEC_INIT
; ..\cstart.c	    82  static void setclockpersec( void );
; ..\cstart.c	    83  extern unsigned long long setfoschz( unsigned long long );
; ..\cstart.c	    84  #endif
; ..\cstart.c	    85  
; ..\cstart.c	    86  #if (  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	    87  #define WDT_CON0        SCU_WDTCPU0CON0
; ..\cstart.c	    88  #define WDT_CON1        SCU_WDTCPU0CON1
; ..\cstart.c	    89  
; ..\cstart.c	    90  static void inline safety_endinit_set(_endinit_t endinit_value);
; ..\cstart.c	    91  
; ..\cstart.c	    92  /* external interface to endinit_set */
; ..\cstart.c	    93  extern void _safety_endinit_clear(void) { safety_endinit_set(_ENDINIT_DISABLE); }
; ..\cstart.c	    94  extern void _safety_endinit_set  (void) { safety_endinit_set(_ENDINIT_ENABLE); }
; ..\cstart.c	    95  
; ..\cstart.c	    96  #if (__HALT_INIT_TC1 && (__HALT_VALUE_TC1 & 0x2)) || (__HALT_INIT_TC2 && (__HALT_VALUE_TC2 & 0x2))
; ..\cstart.c	    97  #if __C_INIT || __CLOCKS_PER_SEC_INIT || __PROF_ENABLE__ || _CALL_ENDINIT || (defined __CALL_INIT)
; ..\cstart.c	    98  /* c init semaphores */
; ..\cstart.c	    99  #if (defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC29X_H)
; ..\cstart.c	   100  #define __AT_NOT_CACHED_MEMORY__        __at(0x70000000)
; ..\cstart.c	   101  #else
; ..\cstart.c	   102  #define __AT_NOT_CACHED_MEMORY__
; ..\cstart.c	   103  #endif
; ..\cstart.c	   104  unsigned int volatile __far __align(4)  _tcx_end_c_init __AT_NOT_CACHED_MEMORY__;       /* _tcx_end_c_init := 1 << core_id */
; ..\cstart.c	   105  #endif
; ..\cstart.c	   106  #endif
; ..\cstart.c	   107  #endif
; ..\cstart.c	   108  
; ..\cstart.c	   109  /*********************************************************************************
; ..\cstart.c	   110   * reset vector
; ..\cstart.c	   111   *********************************************************************************/
; ..\cstart.c	   112  
; ..\cstart.c	   113  #pragma section code libc.reset
; ..\cstart.c	   114  #pragma optimize g
; ..\cstart.c	   115  void _START( void )
; ..\cstart.c	   116  {
; ..\cstart.c	   117          __init_sp();
; ..\cstart.c	   118  }
; ..\cstart.c	   119  #pragma optimize restore
; ..\cstart.c	   120  #pragma section code restore
; ..\cstart.c	   121  
; ..\cstart.c	   122  /*********************************************************************************
; ..\cstart.c	   123   * EBU boot configuration
; ..\cstart.c	   124   *********************************************************************************/
; ..\cstart.c	   125  #if defined EBU_BOOTCFG && defined __EBU_BOOTCFG_VALUE
; ..\cstart.c	   126  #if __EBU_BOOTCFG_INIT
; ..\cstart.c	   127  #pragma section farrom libc.ebu_bootcfg
; ..\cstart.c	   128  const int __far _EBU_BOOTCFG __protect__  = __EBU_BOOTCFG_VALUE; /* locate at RESET + EBU_ALIGN */
; ..\cstart.c	   129  #pragma section farrom restore
; ..\cstart.c	   130  #endif
; ..\cstart.c	   131  #endif
; ..\cstart.c	   132  
; ..\cstart.c	   133  /*********************************************************************************
; ..\cstart.c	   134   * initialize stackpointer
; ..\cstart.c	   135   *********************************************************************************/
; ..\cstart.c	   136  
; ..\cstart.c	   137  static void __noinline__ __noreturn__ __jump__ __init_sp( void )
; ..\cstart.c	   138  {
; ..\cstart.c	   139          /* The initialization of the stackpointer is done in a seperate function, 
; ..\cstart.c	   140             because it must be executed in a function which has no stack use.
; ..\cstart.c	   141             
; ..\cstart.c	   142             When a function uses a stack it will be updated at the start of the 
; ..\cstart.c	   143             function. In this function, however, the stackpointer has an irrelevant
; ..\cstart.c	   144             value at the start of the function. A starting value for the stackpointer
; ..\cstart.c	   145             is determined and written in this function. The update to the 
; ..\cstart.c	   146             stackpointer at the start of the function would therefore be undone.
; ..\cstart.c	   147           */
; ..\cstart.c	   148           
; ..\cstart.c	   149          /* 
; ..\cstart.c	   150           * CPU_TC.033 workaround:
; ..\cstart.c	   151           * The stack pointers are aligned to quad-word boundary to workaround these 
; ..\cstart.c	   152           * functional problems CPU_TC.033.
; ..\cstart.c	   153           * Also the C compiler workaround for the appropriate CPU function problem
; ..\cstart.c	   154           * need to be enabled with --silicon-bug=cpu-tc033, to align circular
; ..\cstart.c	   155           * buffers on a quad-word boundary and to size all stack frames to an integral 
; ..\cstart.c	   156           * number of quad-words.
; ..\cstart.c	   157           */
; ..\cstart.c	   158  #if      __CPU_TC033_INITIAL__
; ..\cstart.c	   159  # define STACK_ALIGN    0xfffffff0
; ..\cstart.c	   160  #else
; ..\cstart.c	   161  # define STACK_ALIGN    0xfffffff8
; ..\cstart.c	   162  #endif
; ..\cstart.c	   163  
; ..\cstart.c	   164          /* 
; ..\cstart.c	   165           * Load user stack pointer.
; ..\cstart.c	   166           * Disable this if not started from RESET vector. (E.g.
; ..\cstart.c	   167           * ROM monitors require to keep in control of vectors)
; ..\cstart.c	   168           */
; ..\cstart.c	   169  #if  __USP_INIT
; ..\cstart.c	   170          unsigned int sp = (unsigned int)(_lc_ue_ustack) & STACK_ALIGN;
; ..\cstart.c	   171          __asm("mov.a\tsp,%0"::"d"(sp));
; ..\cstart.c	   172  #endif
; ..\cstart.c	   173          _start();
; ..\cstart.c	   174  }
; ..\cstart.c	   175  
; ..\cstart.c	   176  /*********************************************************************************
; ..\cstart.c	   177   * startup code
; ..\cstart.c	   178   *********************************************************************************/
; ..\cstart.c	   179  
; ..\cstart.c	   180  static void __noinline__ __noreturn__ __jump__ _start( void )
; ..\cstart.c	   181  {
; ..\cstart.c	   182  
; ..\cstart.c	   183  #if (  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	   184  #if __STADD_INIT_TC1
; ..\cstart.c	   185          /*
; ..\cstart.c	   186           * Set start address of TC1
; ..\cstart.c	   187           * Reset value is 0xAFFFC000
; ..\cstart.c	   188           */
; ..\cstart.c	   189          extern void __noinline__ __noreturn__ __jump__ _start_tc1( void );
; ..\cstart.c	   190          CPU1_PC.U = (unsigned int)_start_tc1;
; ..\cstart.c	   191  #endif
; ..\cstart.c	   192  #if __STADD_INIT_TC2 && !( defined _REGTC26X_H )
; ..\cstart.c	   193          /*
; ..\cstart.c	   194           * Set start address of TC2
; ..\cstart.c	   195           * Reset value is 0xAFFFC000
; ..\cstart.c	   196           */
; ..\cstart.c	   197          extern void __noinline__ __noreturn__ __jump__ _start_tc2( void );
; ..\cstart.c	   198          CPU2_PC.U = (unsigned int)_start_tc2;
; ..\cstart.c	   199  #endif
; ..\cstart.c	   200  #if (__HALT_INIT_TC1 && (__HALT_VALUE_TC1 & 0x2)) || (__HALT_INIT_TC2 && (__HALT_VALUE_TC2 & 0x2))
; ..\cstart.c	   201  #if __C_INIT || __CLOCKS_PER_SEC_INIT || __PROF_ENABLE__ || _CALL_ENDINIT || (defined __CALL_INIT)
; ..\cstart.c	   202          /*
; ..\cstart.c	   203           * Clear end of c init semaphores for all cores
; ..\cstart.c	   204           */
; ..\cstart.c	   205          _tcx_end_c_init = 0;
; ..\cstart.c	   206  #endif
; ..\cstart.c	   207  #endif
; ..\cstart.c	   208          /*
; ..\cstart.c	   209           * A core can be released by resetting its halt state.
; ..\cstart.c	   210           * HALT: 0 R:running W:unchanged
; ..\cstart.c	   211           *       1 R:halted  W:unchanged
; ..\cstart.c	   212           *       2 R:n.a.    W:reset halt
; ..\cstart.c	   213           *       3 R:n.a.    W:set halt when debug enable
; ..\cstart.c	   214           */
; ..\cstart.c	   215  #if __HALT_INIT_TC1
; ..\cstart.c	   216          CPU1_DBGSR.B.HALT=__HALT_VALUE_TC1;
; ..\cstart.c	   217  #endif
; ..\cstart.c	   218  #if __HALT_INIT_TC2 && !( defined _REGTC26X_H )
; ..\cstart.c	   219          CPU2_DBGSR.B.HALT=__HALT_VALUE_TC2;
; ..\cstart.c	   220  #endif
; ..\cstart.c	   221  #endif  
; ..\cstart.c	   222          
; ..\cstart.c	   223          /* Do a dsync before changing any of the csfr values, thus any previous
; ..\cstart.c	   224           * background state gets flushed first. Required for applications that jump
; ..\cstart.c	   225           * to the reset address.
; ..\cstart.c	   226           */
; ..\cstart.c	   227          __dsync();
; ..\cstart.c	   228          
; ..\cstart.c	   229          /* Set the PSW to its reset value in case of a warm start */
; ..\cstart.c	   230  #if __USER_STACK
; ..\cstart.c	   231          __mtcr(PSW, 0x00000980);        /* clear PSW.IS */
; ..\cstart.c	   232  #else
; ..\cstart.c	   233          __mtcr(PSW, 0x00000b80);
; ..\cstart.c	   234  #endif
; ..\cstart.c	   235  
; ..\cstart.c	   236          /* Set the PCXS and PCXO to its reset value in case of a warm start */
; ..\cstart.c	   237          unsigned int pcxi = __mfcr(PCXI);
; ..\cstart.c	   238          pcxi &= 0xfff00000;
; ..\cstart.c	   239          __mtcr(PCXI, pcxi);
; ..\cstart.c	   240  
; ..\cstart.c	   241  #if (  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	   242          /*
; ..\cstart.c	   243           * Clear the ENDINIT bit in the WDTSCON0 register in order
; ..\cstart.c	   244           * to disable the write-protection for safety-critical registers
; ..\cstart.c	   245           * protected via the safety EndInit feature.
; ..\cstart.c	   246           */
; ..\cstart.c	   247          safety_endinit_set(_ENDINIT_DISABLE);
; ..\cstart.c	   248          
; ..\cstart.c	   249          /*
; ..\cstart.c	   250           * Disable the safety watchdog if requested. Safety watchdog
; ..\cstart.c	   251           * is enabled by default. The safety watchdog is disabled after
; ..\cstart.c	   252           * ENDINIT is set by safety_endinit_set().
; ..\cstart.c	   253           */       
; ..\cstart.c	   254  #if __SAFETY_WATCHDOG_DISABLE
; ..\cstart.c	   255          SCU_WDTSCON1.U |= 0x8;
; ..\cstart.c	   256          safety_endinit_set(_ENDINIT_ENABLE);
; ..\cstart.c	   257          safety_endinit_set(_ENDINIT_DISABLE);
; ..\cstart.c	   258  #endif
; ..\cstart.c	   259          
; ..\cstart.c	   260  #endif
; ..\cstart.c	   261          
; ..\cstart.c	   262          /*
; ..\cstart.c	   263           * Clear the ENDINIT bit in the WDT_CON0 register in order
; ..\cstart.c	   264           * to disable the write-protection for registers protected 
; ..\cstart.c	   265           * via the EndInit feature (for example: WDT_CON1).
; ..\cstart.c	   266           */
; ..\cstart.c	   267          endinit_set(_ENDINIT_DISABLE);
; ..\cstart.c	   268          
; ..\cstart.c	   269          /*
; ..\cstart.c	   270           * Disable the Watchdog if requested. Watchdog is enabled by default.
; ..\cstart.c	   271           * The Watchdog is disabled after ENDINIT is set by endinit_set().
; ..\cstart.c	   272           */       
; ..\cstart.c	   273  #if __WATCHDOG_DISABLE
; ..\cstart.c	   274          WDT_CON1.U |= 0x8;
; ..\cstart.c	   275          endinit_set(_ENDINIT_ENABLE);
; ..\cstart.c	   276          endinit_set(_ENDINIT_DISABLE);
; ..\cstart.c	   277  #endif
; ..\cstart.c	   278  
; ..\cstart.c	   279          /*
; ..\cstart.c	   280           * PMI_TC.003 workaround:
; ..\cstart.c	   281           * The TLB-A and TLB-B mappings are set to a page size of 16KB.
; ..\cstart.c	   282           */
; ..\cstart.c	   283  #if __PMI_TC003_INITIAL__  && defined MMU_CON
; ..\cstart.c	   284          unsigned int mmu_con = __mfcr(MMU_CON);
; ..\cstart.c	   285          mmu_con &= 0xffffffe1;      /* clear SZA and SZB */
; ..\cstart.c	   286          mmu_con |= 0x00000014;      /* set SZA=SZB=16k   */       
; ..\cstart.c	   287          __mtcr(MMU_CON, mmu_con);
; ..\cstart.c	   288  #endif
; ..\cstart.c	   289  
; ..\cstart.c	   290          /*
; ..\cstart.c	   291           * Load Base Address of Trap Vector Table.
; ..\cstart.c	   292           * Disable this if not started from RESET vector. (E.g.
; ..\cstart.c	   293           * ROM monitors require to keep in control of vectors)
; ..\cstart.c	   294           */
; ..\cstart.c	   295  #if __BTV_INIT
; ..\cstart.c	   296          __mtcr(BTV,  (unsigned int)_lc_u_trap_tab);
; ..\cstart.c	   297  #endif
; ..\cstart.c	   298  
; ..\cstart.c	   299          /*
; ..\cstart.c	   300           * Load Base Address of Interrupt Vector Table.
; ..\cstart.c	   301           * Disable this if not started from RESET vector. (E.g.
; ..\cstart.c	   302           * ROM monitors require to keep in control of vectors)
; ..\cstart.c	   303           */
; ..\cstart.c	   304  #if __BIV_INIT
; ..\cstart.c	   305  #if __BIV_SINGLE_INIT && (defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	   306          /*
; ..\cstart.c	   307           * Single Entry Vector Table, for core tc1.6.x, is supported
; ..\cstart.c	   308           * by _sevt_isr_tc0() calling interrupt handlers installed
; ..\cstart.c	   309           * with _sevt_isr_install() stored in _sevt_isrs_tc0 list.
; ..\cstart.c	   310           * The _sevt_isr_tc0() is located at interrupt vector table
; ..\cstart.c	   311           * entry 64. The start address of the interrupt vector table
; ..\cstart.c	   312           * is defined by linker definition INTTAB0, default value
; ..\cstart.c	   313           *_lc_u_int_tab is 0xa00f0000+0x800.
; ..\cstart.c	   314           */
; ..\cstart.c	   315  #pragma extern _sevt_isr_tc0
; ..\cstart.c	   316          __mtcr(BIV, (unsigned int)(_lc_u_int_tab) | (0xff<<3) | 1 );
; ..\cstart.c	   317  #else
; ..\cstart.c	   318  #if __BIV_8BYTE_INIT && (defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	   319          __mtcr(BIV, (unsigned int)(_lc_u_int_tab) | 1 );        /* 8 Byte vector spacing */
; ..\cstart.c	   320  #else
; ..\cstart.c	   321          __mtcr(BIV, (unsigned int)(_lc_u_int_tab));             /* 32 Byte vector spacing */
; ..\cstart.c	   322  #endif
; ..\cstart.c	   323  #endif
; ..\cstart.c	   324  #endif
; ..\cstart.c	   325  
; ..\cstart.c	   326          /*
; ..\cstart.c	   327           * Load interupt stack pointer.
; ..\cstart.c	   328           * Disable this if not started from RESET vector. (E.g.
; ..\cstart.c	   329           * ROM monitors require to keep in control of vectors)
; ..\cstart.c	   330           */
; ..\cstart.c	   331  #if __ISP_INIT
; ..\cstart.c	   332          unsigned int isp = (unsigned int)(_lc_ue_istack) & STACK_ALIGN;
; ..\cstart.c	   333          __mtcr(ISP, isp);
; ..\cstart.c	   334  #endif
; ..\cstart.c	   335                                                            
; ..\cstart.c	   336          /*
; ..\cstart.c	   337           * PMU/PMI configuration.
; ..\cstart.c	   338           */
; ..\cstart.c	   339  #if defined PMI_CON0 && defined __PMI_CON0_VALUE
; ..\cstart.c	   340          if(__PMI_CON0_INIT)  PMI_CON0.U = __PMI_CON0_VALUE;        
; ..\cstart.c	   341  #endif
; ..\cstart.c	   342  #if defined PMI_CON1 && defined __PMI_CON1_VALUE
; ..\cstart.c	   343          if(__PMI_CON1_INIT)  PMI_CON1.U = __PMI_CON1_VALUE;        
; ..\cstart.c	   344  #endif  
; ..\cstart.c	   345  #if     defined PMI_CON2 && defined __PMI_CON2_VALUE && \ 
; ..\cstart.c	   346          (  defined _REGTC1337_H || defined _REGTC1367_H || defined _REGTC1387_H || defined _REGTC1728_H \ 
; ..\cstart.c	   347          || defined _REGTC1746_H || defined _REGTC1747_H || defined _REGTC1768_H || defined _REGTC1782_H \ 
; ..\cstart.c	   348          || defined _REGTC1784_H || defined _REGTC1184_H || defined _REGTC1797_H || defined _REGTC1197_H \ 
; ..\cstart.c	   349          || defined _REGTC1734_H || defined _REGTC1767_H || defined _REGTC1736_H || defined _REGTC1732_H \ 
; ..\cstart.c	   350          || defined _REGTC1738_H || defined _REGTC1167_H || defined _REGTC1735_H || defined _REGTC1724_H )
; ..\cstart.c	   351          if(__PMI_CON2_INIT)  PMI_CON2.U = __PMI_CON2_VALUE;        
; ..\cstart.c	   352  #endif
; ..\cstart.c	   353          
; ..\cstart.c	   354  #if defined PMU_EIFCON && defined __PMU_EIFCON_VALUE
; ..\cstart.c	   355          if(__PMU_EIFCON_INIT)  PMU_EIFCON.U = __PMU_EIFCON_VALUE;
; ..\cstart.c	   356  #endif
; ..\cstart.c	   357  
; ..\cstart.c	   358          /*
; ..\cstart.c	   359           * DMI configuration.
; ..\cstart.c	   360           */
; ..\cstart.c	   361  #if     defined DMI_CON && defined __DMI_CON_VALUE && \ 
; ..\cstart.c	   362          (  defined _REGTC1167_H || defined _REGTC1197_H || defined _REGTC1337_H || defined _REGTC1367_H \ 
; ..\cstart.c	   363          || defined _REGTC1387_H || defined _REGTC1728_H || defined _REGTC1734_H || defined _REGTC1738_H \ 
; ..\cstart.c	   364          || defined _REGTC1746_H || defined _REGTC1747_H || defined _REGTC1767_H || defined _REGTC1768_H \ 
; ..\cstart.c	   365          || defined _REGTC1782_H || defined _REGTC1784_H || defined _REGTC1184_H || defined _REGTC1797_H \ 
; ..\cstart.c	   366          || defined _REGTC1724_H )
; ..\cstart.c	   367          if(__DMI_CON_INIT)  DMI_CON.U = __DMI_CON_VALUE;        
; ..\cstart.c	   368  #endif
; ..\cstart.c	   369          
; ..\cstart.c	   370          /*
; ..\cstart.c	   371           * Data cache control (Reset 0H).
; ..\cstart.c	   372           * CPU_TC013 workaround:
; ..\cstart.c	   373           * The 16KB D-Cache is enabled to workaround
; ..\cstart.c	   374           * the CPU_TC013 functional problem.     
; ..\cstart.c	   375           * NOTE: Setting the D-Cache size must be done at the
; ..\cstart.c	   376           *       very beginning of the startup code.
; ..\cstart.c	   377           */
; ..\cstart.c	   378  #if defined  DMU_CON
; ..\cstart.c	   379  #  if __CPU_TC013_INITIAL__ 
; ..\cstart.c	   380          DMU_CON.U = 0x1;
; ..\cstart.c	   381  #  endif
; ..\cstart.c	   382  #endif
; ..\cstart.c	   383  
; ..\cstart.c	   384          /*
; ..\cstart.c	   385           * PCON0 configuration.
; ..\cstart.c	   386           */
; ..\cstart.c	   387  #if     defined PCON0 && defined __PCON0_VALUE
; ..\cstart.c	   388          if(__PCON0_INIT) __mtcr(PCON0, __PCON0_VALUE);
; ..\cstart.c	   389  #endif
; ..\cstart.c	   390  
; ..\cstart.c	   391          /*
; ..\cstart.c	   392           * DCON0 configuration.
; ..\cstart.c	   393           */
; ..\cstart.c	   394  #if     defined DCON0 && defined __DCON0_VALUE
; ..\cstart.c	   395          if(__DCON0_INIT) __mtcr(DCON0, __DCON0_VALUE);
; ..\cstart.c	   396  #endif
; ..\cstart.c	   397          
; ..\cstart.c	   398          /*
; ..\cstart.c	   399           * Bus configuration EBU_CLC within endinit.
; ..\cstart.c	   400           */
; ..\cstart.c	   401  #  if defined EBU_CLC && defined __EBU_CLC_VALUE
; ..\cstart.c	   402          if(__EBU_CLC_INIT)  EBU_CLC.U = __EBU_CLC_VALUE;
; ..\cstart.c	   403  #  endif
; ..\cstart.c	   404  
; ..\cstart.c	   405          /*
; ..\cstart.c	   406           *      Setting up the PLL after Reset.
; ..\cstart.c	   407           *
; ..\cstart.c	   408           *      After reset, the system clock will be running at the VCO
; ..\cstart.c	   409           *      base frequency devided by a factor KDIV. To set up the PLL
; ..\cstart.c	   410           *      ater resert, next action must be executed.
; ..\cstart.c	   411           */
; ..\cstart.c	   412  #if defined PLL_CLC && defined __PLL_CLC_VALUE
; ..\cstart.c	   413  #if     __PLL_CLC_INIT
; ..\cstart.c	   414  #if     ( defined _REGTC11IB_H )
; ..\cstart.c	   415  #define __PLLBYP        PLL1_BP
; ..\cstart.c	   416  #define __LOCK          PLL1_LOCK
; ..\cstart.c	   417          if ( PLL_CLC.B.__PLLBYP == 0 )
; ..\cstart.c	   418          {
; ..\cstart.c	   419                  PLL_CLC.U = __PLL_CLC_VALUE;
; ..\cstart.c	   420                  while( PLL_CLC.B.__LOCK==0);                      /* Wait until the PLL becomes locked */
; ..\cstart.c	   421          }
; ..\cstart.c	   422  #else
; ..\cstart.c	   423  #define __PLL_CLC_SYSFS_VALUE   ((__PLL_CLC_VALUE>>2)&0x1)
; ..\cstart.c	   424  #define __PLL_CLC_VCOBYP_VALUE  ((__PLL_CLC_VALUE>>5)&0x1)
; ..\cstart.c	   425  #define __PLL_CLC_VCOSEL_VALUE  ((__PLL_CLC_VALUE>>6)&0x3)
; ..\cstart.c	   426  #define __PLL_CLC_KDIV_VALUE    ((__PLL_CLC_VALUE>>8)&0xf)
; ..\cstart.c	   427  #define __PLL_CLC_PDIV_VALUE    ((__PLL_CLC_VALUE>>13)&0x3)
; ..\cstart.c	   428  #define __PLL_CLC_NDIV_VALUE    ((__PLL_CLC_VALUE>>16)&0x7f)
; ..\cstart.c	   429          if ( PLL_CLC.B.BYPPIN == 0 )
; ..\cstart.c	   430          {
; ..\cstart.c	   431  #if     ( defined _REGTC1130_H )
; ..\cstart.c	   432                  while (OSC_CON.B.OSCR==1);                      /* Wait until the oscillator is running */
; ..\cstart.c	   433  #else
; ..\cstart.c	   434                  while (OSC_CON.B.OSCR==0);                      /* Wait until the oscillator is running */
; ..\cstart.c	   435  #endif
; ..\cstart.c	   436                  PLL_CLC.B.VCOBYP = 1;                           /* Enabled the VCO Bypass Mode */
; ..\cstart.c	   437                  PLL_CLC.B.VCOSEL = __PLL_CLC_VCOSEL_VALUE;      /* Select the VCO band */
; ..\cstart.c	   438                  PLL_CLC.B.PDIV = __PLL_CLC_PDIV_VALUE;
; ..\cstart.c	   439                  PLL_CLC.B.KDIV = __PLL_CLC_KDIV_VALUE;
; ..\cstart.c	   440                  PLL_CLC.B.NDIV = __PLL_CLC_NDIV_VALUE;
; ..\cstart.c	   441  #if __PLL_CLC_VCOBYP_VALUE==0
; ..\cstart.c	   442                  PLL_CLC.B.OSCDISC = 0;                          /* Connect the oscillator to the PLL */
; ..\cstart.c	   443                  while( PLL_CLC.B.LOCK==0);                      /* Wait until the PLL becomes locked */
; ..\cstart.c	   444                  PLL_CLC.B.VCOBYP = 0;                           /* Disabled the VCO Bypass Mode */
; ..\cstart.c	   445  #endif
; ..\cstart.c	   446          }
; ..\cstart.c	   447  #if     ( defined _REGTC1130_H )
; ..\cstart.c	   448          PLL_CLC.B.SYSFSL = __PLL_CLC_SYSFS_VALUE;                /* System frequency select */
; ..\cstart.c	   449  #else
; ..\cstart.c	   450  #if     (  defined _REGTC1762_H || defined _REGTC1764_H || defined _REGTC1766B_H \ 
; ..\cstart.c	   451          || defined _REGTC1164_H || defined _REGTC1166_H )
; ..\cstart.c	   452          PLL_CLC.B.RSV = __PLL_CLC_SYSFS_VALUE;                  /* System frequency select */
; ..\cstart.c	   453  #else
; ..\cstart.c	   454          PLL_CLC.B.SYSFS = __PLL_CLC_SYSFS_VALUE;                /* System frequency select */
; ..\cstart.c	   455  #endif
; ..\cstart.c	   456  #endif
; ..\cstart.c	   457  #endif
; ..\cstart.c	   458  #endif
; ..\cstart.c	   459  #endif
; ..\cstart.c	   460  
; ..\cstart.c	   461           /*
; ..\cstart.c	   462            * Configure CCU Clock Control
; ..\cstart.c	   463            *
; ..\cstart.c	   464            * For AURIX derivatives it is required to set the update request only
; ..\cstart.c	   465            * in the last CCUCON that is initialized. Set CCUCONx.UP where x is
; ..\cstart.c	   466            * the last one. A new complete parameter set is transferred to
; ..\cstart.c	   467            * the CCU.
; ..\cstart.c	   468            */
; ..\cstart.c	   469  #if defined SCU_CCUCON0 && defined __SCU_CCUCON0_VALUE
; ..\cstart.c	   470           if(__SCU_CCUCON0_INIT)  SCU_CCUCON0.U = __SCU_CCUCON0_VALUE;
; ..\cstart.c	   471  #endif
; ..\cstart.c	   472  
; ..\cstart.c	   473  #if defined SCU_CCUCON1 && defined __SCU_CCUCON1_VALUE
; ..\cstart.c	   474           if(__SCU_CCUCON1_INIT)  SCU_CCUCON1.U = __SCU_CCUCON1_VALUE;
; ..\cstart.c	   475  #endif
; ..\cstart.c	   476  
; ..\cstart.c	   477  #if defined SCU_CCUCON2 && defined __SCU_CCUCON2_VALUE
; ..\cstart.c	   478           if(__SCU_CCUCON2_INIT)  SCU_CCUCON2.U = __SCU_CCUCON2_VALUE;
; ..\cstart.c	   479  #endif
; ..\cstart.c	   480           
; ..\cstart.c	   481          /*
; ..\cstart.c	   482           * System Oscillator configuration
; ..\cstart.c	   483           */
; ..\cstart.c	   484  #if defined SCU_OSCCON && defined __SCU_OSCCON_VALUE
; ..\cstart.c	   485  #if __SCU_OSCCON_INIT
; ..\cstart.c	   486          SCU_OSCCON.U=__SCU_OSCCON_VALUE;
; ..\cstart.c	   487          
; ..\cstart.c	   488          while(SCU_OSCCON.B.PLLLV==0);           /* Oscillator not too low */
; ..\cstart.c	   489          while(SCU_OSCCON.B.PLLHV==0);           /* Oscillator not too high */
; ..\cstart.c	   490  #endif
; ..\cstart.c	   491  #endif
; ..\cstart.c	   492  
; ..\cstart.c	   493          /*
; ..\cstart.c	   494           * Configure PLL Prescaler Mode.
; ..\cstart.c	   495           */
; ..\cstart.c	   496  #if defined SCU_PLLCON1 && defined __SCU_PLLCON1_VALUE
; ..\cstart.c	   497  #if __SCU_PLLCON1_INIT
; ..\cstart.c	   498  #define __SCU_PLLCON1__K1DIV_VALUE      ((__SCU_PLLCON1_VALUE>>16)&0x3f)
; ..\cstart.c	   499          SCU_PLLCON1.B.K1DIV=__SCU_PLLCON1__K1DIV_VALUE;
; ..\cstart.c	   500          while(SCU_PLLSTAT.B.K1RDY==0);          /* Wait until K1-Divider is ready to operate */
; ..\cstart.c	   501  #endif
; ..\cstart.c	   502  #endif
; ..\cstart.c	   503  
; ..\cstart.c	   504  #if defined SCU_PLLCON0 && defined __SCU_PLLCON0_VALUE
; ..\cstart.c	   505  #if     __SCU_PLLCON0_INIT
; ..\cstart.c	   506          SCU_PLLCON0.B.VCOBYP=1;                 /* Enabled the VCO Bypass Mode */
; ..\cstart.c	   507          while(SCU_PLLSTAT.B.VCOBYST==0);        /* Wait until prescaler mode is entered */
; ..\cstart.c	   508  
; ..\cstart.c	   509  #define __SCU_PLLCON0__VCOPWD_VALUE     ((__SCU_PLLCON0_VALUE>>1)&0x1)
; ..\cstart.c	   510  #define __SCU_PLLCON0__NDIV_VALUE       ((__SCU_PLLCON0_VALUE>>9)&0x7f)
; ..\cstart.c	   511  #define __SCU_PLLCON0__PDIV_VALUE       ((__SCU_PLLCON0_VALUE>>24)&0xf)
; ..\cstart.c	   512          SCU_PLLCON0.B.PDIV=__SCU_PLLCON0__PDIV_VALUE;
; ..\cstart.c	   513          SCU_PLLCON0.B.NDIV=__SCU_PLLCON0__NDIV_VALUE;
; ..\cstart.c	   514          SCU_PLLCON0.B.VCOPWD=__SCU_PLLCON0__VCOPWD_VALUE; /* power down VCO */
; ..\cstart.c	   515  
; ..\cstart.c	   516  #if __SCU_PLLCON0__VCOPWD_VALUE==0
; ..\cstart.c	   517          /*
; ..\cstart.c	   518           * Configure PLL normal mode.
; ..\cstart.c	   519           */
; ..\cstart.c	   520          SCU_PLLCON0.B.OSCDISCDIS=1;             /* Automatic oscillator disconnect disabled */
; ..\cstart.c	   521          SCU_PLLCON0.B.CLRFINDIS=1;              /* Connect VCO to the oscillator */
; ..\cstart.c	   522          while(SCU_PLLSTAT.B.FINDIS==1);         /* Wait until oscillator is connected to the VCO */
; ..\cstart.c	   523          SCU_PLLCON0.B.RESLD=1;                  /* Restart VCO lock detection */
; ..\cstart.c	   524          while(SCU_PLLSTAT.B.VCOLOCK==0);        /* Wait until the VCO becomes locked */
; ..\cstart.c	   525          SCU_PLLCON0.B.VCOBYP=0;                 /* Disable the VCO Bypass Mode */
; ..\cstart.c	   526          while(SCU_PLLSTAT.B.VCOBYST==1);        /* Wait until normal mode is entered */
; ..\cstart.c	   527          SCU_PLLCON0.B.OSCDISCDIS=0;             /* Automatic oscillator disconnect enabled */
; ..\cstart.c	   528  #endif
; ..\cstart.c	   529  #endif
; ..\cstart.c	   530  #endif
; ..\cstart.c	   531  
; ..\cstart.c	   532          /*
; ..\cstart.c	   533           *      PLL K2 ramp up
; ..\cstart.c	   534           */
; ..\cstart.c	   535  #if defined SCU_PLLCON1 && defined __SCU_PLLCON1_VALUE
; ..\cstart.c	   536  #if __SCU_PLLCON1_INIT
; ..\cstart.c	   537  #define __SCU_PLLCON1__K2DIV_VALUE      ((__SCU_PLLCON1_VALUE>>0)&0x3f)
; ..\cstart.c	   538  #if __PLL_K2_RAMPUP
; ..\cstart.c	   539  #if defined SCU_PLLSTAT && defined __fOSC
; ..\cstart.c	   540  #if     (  defined _REGTC1167_H || defined _REGTC1197_H || defined _REGTC1337_H || defined _REGTC1367_H \ 
; ..\cstart.c	   541          || defined _REGTC1387_H || defined _REGTC1732_H || defined _REGTC1728_H || defined _REGTC1734_H \ 
; ..\cstart.c	   542          || defined _REGTC1735_H || defined _REGTC1736_H || defined _REGTC1738_H || defined _REGTC1746_H \ 
; ..\cstart.c	   543          || defined _REGTC1747_H || defined _REGTC1748_H || defined _REGTC1767_H || defined _REGTC1768_H \ 
; ..\cstart.c	   544          || defined _REGTC1782_H || defined _REGTC1784_H || defined _REGTC1184_H || defined _REGTC1797_H \ 
; ..\cstart.c	   545          || defined _REGTC1791_H || defined _REGTC1793_H || defined _REGTC1798_H || defined _REGTC1724_H \ 
; ..\cstart.c	   546          || defined _REGTC2D5T_H || defined _REGTC27X_H  || defined _REGTC27XB_H || defined _REGTC26X_H \ 
; ..\cstart.c	   547          || defined _REGTC29X_H)
; ..\cstart.c	   548  #if     ( defined _REGTC2D5T_H )
; ..\cstart.c	   549  #define PLL_K2_RAMPUP_STM_CLC_RMC       (STM0_CLC.B.RMC)
; ..\cstart.c	   550  #else
; ..\cstart.c	   551  #if ( defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	   552  #define PLL_K2_RAMPUP_STM_CLC_RMC       1
; ..\cstart.c	   553  #else
; ..\cstart.c	   554  #define PLL_K2_RAMPUP_STM_CLC_RMC       (STM_CLC.B.RMC)
; ..\cstart.c	   555  #endif
; ..\cstart.c	   556  #endif
; ..\cstart.c	   557  #if ( defined _REGTC1337_H || defined _REGTC1367_H || defined _REGTC1387_H || defined _REGTC1768_H )
; ..\cstart.c	   558  #define PLL_K2_RAMPUP_SYSCLK(CPUCLK)    (CPUCLK)
; ..\cstart.c	   559  #else
; ..\cstart.c	   560  #if ( defined _REGTC2D5T_H )
; ..\cstart.c	   561  #define PLL_K2_RAMPUP_SYSCLK(CPUCLK)    (CPUCLK/(SCU_CCUCON0.B.SPBDIV+1))
; ..\cstart.c	   562  #else
; ..\cstart.c	   563  #if ( defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	   564  #define PLL_K2_RAMPUP_SYSCLK(CPUCLK)    (CPUCLK/SCU_CCUCON1.B.STMDIV)
; ..\cstart.c	   565  #else
; ..\cstart.c	   566  #define PLL_K2_RAMPUP_SYSCLK(CPUCLK)    (CPUCLK/(SCU_CCUCON0.B.FPIDIV+1))
; ..\cstart.c	   567  #endif
; ..\cstart.c	   568  #endif
; ..\cstart.c	   569  #endif
; ..\cstart.c	   570  #define USECCLK         (PLL_K2_RAMPUP_SYSCLK(((SCU_PLLCON0.B.NDIV+1)*(__fOSC/1000000))/((SCU_PLLCON0.B.PDIV+1)*(SCU_PLLCON1.B.K2DIV+1)))/PLL_K2_RAMPUP_STM_CLC_RMC)
; ..\cstart.c	   571  #define WAITUSEC        (USECCLK*20)    /* wait 20 usec */
; ..\cstart.c	   572  #endif
; ..\cstart.c	   573  #endif
; ..\cstart.c	   574  #pragma tradeoff 0      /* avoid call to run-time function */
; ..\cstart.c	   575          while ( SCU_PLLCON1.B.K2DIV > __SCU_PLLCON1__K2DIV_VALUE )
; ..\cstart.c	   576          {
; ..\cstart.c	   577                  unsigned int wait;
; ..\cstart.c	   578  
; ..\cstart.c	   579                  SCU_PLLCON1.B.K2DIV-=1;
; ..\cstart.c	   580                  wait = SYSTIME_LOW+WAITUSEC;
; ..\cstart.c	   581  
; ..\cstart.c	   582                  while( SYSTIME_LOW < wait ) ;
; ..\cstart.c	   583          }
; ..\cstart.c	   584  #pragma tradeoff restore
; ..\cstart.c	   585  #else
; ..\cstart.c	   586          SCU_PLLCON1.B.K2DIV=__SCU_PLLCON1__K2DIV_VALUE;
; ..\cstart.c	   587  #endif
; ..\cstart.c	   588  #endif
; ..\cstart.c	   589  #endif
; ..\cstart.c	   590  
; ..\cstart.c	   591          /*
; ..\cstart.c	   592           * Configure flash registers.
; ..\cstart.c	   593           */
; ..\cstart.c	   594  #if defined FLASH0_FCON && defined __FLASH0_FCON_VALUE
; ..\cstart.c	   595          if(__FLASH0_FCON_INIT)  FLASH0_FCON.U = __FLASH0_FCON_VALUE;        
; ..\cstart.c	   596  #endif
; ..\cstart.c	   597  #if defined FLASH1_FCON && defined __FLASH1_FCON_VALUE
; ..\cstart.c	   598          if(__FLASH1_FCON_INIT)  FLASH1_FCON.U = __FLASH1_FCON_VALUE;        
; ..\cstart.c	   599  #endif
; ..\cstart.c	   600          
; ..\cstart.c	   601          /*
; ..\cstart.c	   602           * Configure system clock register.
; ..\cstart.c	   603           */
; ..\cstart.c	   604  #if defined STM_CLC && defined __STM_CLC_VALUE
; ..\cstart.c	   605          if(__STM_CLC_INIT)  STM_CLC.U = __STM_CLC_VALUE;        
; ..\cstart.c	   606  #endif
; ..\cstart.c	   607  
; ..\cstart.c	   608          /*
; ..\cstart.c	   609           * Enable the GTM to get MCS memory access,
; ..\cstart.c	   610           * required for MCS initialization which
; ..\cstart.c	   611           * is performed by _c_init.
; ..\cstart.c	   612           */
; ..\cstart.c	   613  #if defined GTM_CLC && defined __GTM_CLC_VALUE
; ..\cstart.c	   614          if(__GTM_CLC_INIT)  GTM_CLC.U = __GTM_CLC_VALUE;
; ..\cstart.c	   615  #endif
; ..\cstart.c	   616          
; ..\cstart.c	   617          
; ..\cstart.c	   618          /*
; ..\cstart.c	   619           * Set the ENDINIT bit in the WDT_CON0 register again
; ..\cstart.c	   620           * to enable the write-protection.
; ..\cstart.c	   621           */
; ..\cstart.c	   622          endinit_set(_ENDINIT_ENABLE);
; ..\cstart.c	   623  
; ..\cstart.c	   624  #if (  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	   625          /*
; ..\cstart.c	   626           * Set the ENDINIT bit in the WDTSCON0 register to enable the
; ..\cstart.c	   627           * safety-critical register write-protection.
; ..\cstart.c	   628           */
; ..\cstart.c	   629          safety_endinit_set(_ENDINIT_ENABLE);
; ..\cstart.c	   630  #endif
; ..\cstart.c	   631          
; ..\cstart.c	   632          /*
; ..\cstart.c	   633           * Initialize Bus configuration registers:
; ..\cstart.c	   634           * Set register-values according to define's created by the GUI
; ..\cstart.c	   635           * 
; ..\cstart.c	   636           * The recommended sequence of setting registers is as follows:
; ..\cstart.c	   637           * 1.EBUCON
; ..\cstart.c	   638           * 2.All other EBU registers except SDRAM specific registers
; ..\cstart.c	   639           * 3.SDRMCON0
; ..\cstart.c	   640           * 4.SDRMMOD0
; ..\cstart.c	   641           * 5.SDRMREF0
; ..\cstart.c	   642           * 6.SDRMCON1
; ..\cstart.c	   643           * 7.SDRMMOD1
; ..\cstart.c	   644           * 8.SDRMREF1
; ..\cstart.c	   645           */
; ..\cstart.c	   646  #if defined EBU_CON && defined __EBU_CON_VALUE
; ..\cstart.c	   647          if(__EBU_CON_INIT)  EBU_CON.U = __EBU_CON_VALUE;
; ..\cstart.c	   648  #endif
; ..\cstart.c	   649  #if defined EBU_ADDRSEL0 && defined __EBU_ADDRSEL0_VALUE
; ..\cstart.c	   650          if(__EBU_ADDRSEL0_INIT)  EBU_ADDRSEL0.U = __EBU_ADDRSEL0_VALUE;
; ..\cstart.c	   651  #endif
; ..\cstart.c	   652  #if defined EBU_ADDRSEL1 && defined __EBU_ADDRSEL1_VALUE
; ..\cstart.c	   653          if(__EBU_ADDRSEL1_INIT)  EBU_ADDRSEL1.U = __EBU_ADDRSEL1_VALUE;
; ..\cstart.c	   654  #endif
; ..\cstart.c	   655  #if defined EBU_ADDRSEL2 && defined __EBU_ADDRSEL2_VALUE
; ..\cstart.c	   656          if(__EBU_ADDRSEL2_INIT)  EBU_ADDRSEL2.U = __EBU_ADDRSEL2_VALUE;
; ..\cstart.c	   657  #endif
; ..\cstart.c	   658  #if defined EBU_ADDRSEL3 && defined __EBU_ADDRSEL3_VALUE
; ..\cstart.c	   659          if(__EBU_ADDRSEL3_INIT)  EBU_ADDRSEL3.U = __EBU_ADDRSEL3_VALUE;
; ..\cstart.c	   660  #endif
; ..\cstart.c	   661  #if defined EBU_ADDRSEL4 && defined __EBU_ADDRSEL4_VALUE
; ..\cstart.c	   662          if(__EBU_ADDRSEL4_INIT)  EBU_ADDRSEL4.U = __EBU_ADDRSEL4_VALUE;
; ..\cstart.c	   663  #endif
; ..\cstart.c	   664  #if defined EBU_ADDRSEL5 && defined __EBU_ADDRSEL5_VALUE
; ..\cstart.c	   665          if(__EBU_ADDRSEL5_INIT)  EBU_ADDRSEL5.U = __EBU_ADDRSEL5_VALUE;
; ..\cstart.c	   666  #endif
; ..\cstart.c	   667  #if defined EBU_ADDRSEL6 && defined __EBU_ADDRSEL6_VALUE
; ..\cstart.c	   668          if(__EBU_ADDRSEL6_INIT)  EBU_ADDRSEL6.U = __EBU_ADDRSEL6_VALUE;
; ..\cstart.c	   669  #endif
; ..\cstart.c	   670  #if defined EBU_BFCON && defined __EBU_BFCON_VALUE
; ..\cstart.c	   671          if(__EBU_BFCON_INIT)  EBU_BFCON.U = __EBU_BFCON_VALUE;
; ..\cstart.c	   672  #endif
; ..\cstart.c	   673  #if defined EBU_BUSAP0 && defined __EBU_BUSAP0_VALUE
; ..\cstart.c	   674          if(__EBU_BUSAP0_INIT)  EBU_BUSAP0.U = __EBU_BUSAP0_VALUE;
; ..\cstart.c	   675  #endif
; ..\cstart.c	   676  #if defined EBU_BUSAP1 && defined __EBU_BUSAP1_VALUE
; ..\cstart.c	   677          if(__EBU_BUSAP1_INIT)  EBU_BUSAP1.U = __EBU_BUSAP1_VALUE;
; ..\cstart.c	   678  #endif
; ..\cstart.c	   679  #if defined EBU_BUSAP2 && defined __EBU_BUSAP2_VALUE
; ..\cstart.c	   680          if(__EBU_BUSAP2_INIT)  EBU_BUSAP2.U = __EBU_BUSAP2_VALUE;
; ..\cstart.c	   681  #endif
; ..\cstart.c	   682  #if defined EBU_BUSAP3 && defined __EBU_BUSAP3_VALUE
; ..\cstart.c	   683          if(__EBU_BUSAP3_INIT)  EBU_BUSAP3.U = __EBU_BUSAP3_VALUE;
; ..\cstart.c	   684  #endif
; ..\cstart.c	   685  #if defined EBU_BUSAP4 && defined __EBU_BUSAP4_VALUE
; ..\cstart.c	   686          if(__EBU_BUSAP4_INIT)  EBU_BUSAP4.U = __EBU_BUSAP4_VALUE;
; ..\cstart.c	   687  #endif
; ..\cstart.c	   688  #if defined EBU_BUSAP5 && defined __EBU_BUSAP5_VALUE
; ..\cstart.c	   689          if(__EBU_BUSAP5_INIT)  EBU_BUSAP5.U = __EBU_BUSAP5_VALUE;
; ..\cstart.c	   690  #endif
; ..\cstart.c	   691  #if defined EBU_BUSAP6 && defined __EBU_BUSAP6_VALUE
; ..\cstart.c	   692          if(__EBU_BUSAP6_INIT)  EBU_BUSAP6.U = __EBU_BUSAP6_VALUE;
; ..\cstart.c	   693  #endif
; ..\cstart.c	   694  #if defined EBU_BUSCON0 && defined __EBU_BUSCON0_VALUE
; ..\cstart.c	   695          if(__EBU_BUSCON0_INIT)  EBU_BUSCON0.U = __EBU_BUSCON0_VALUE;
; ..\cstart.c	   696  #endif
; ..\cstart.c	   697  #if defined EBU_BUSCON1 && defined __EBU_BUSCON1_VALUE
; ..\cstart.c	   698          if(__EBU_BUSCON1_INIT)  EBU_BUSCON1.U = __EBU_BUSCON1_VALUE;
; ..\cstart.c	   699  #endif
; ..\cstart.c	   700  #if defined EBU_BUSCON2 && defined __EBU_BUSCON2_VALUE
; ..\cstart.c	   701          if(__EBU_BUSCON2_INIT)  EBU_BUSCON2.U = __EBU_BUSCON2_VALUE;
; ..\cstart.c	   702  #endif
; ..\cstart.c	   703  #if defined EBU_BUSCON3 && defined __EBU_BUSCON3_VALUE
; ..\cstart.c	   704          if(__EBU_BUSCON3_INIT)  EBU_BUSCON3.U = __EBU_BUSCON3_VALUE;
; ..\cstart.c	   705  #endif
; ..\cstart.c	   706  #if defined EBU_BUSCON4 && defined __EBU_BUSCON4_VALUE
; ..\cstart.c	   707          if(__EBU_BUSCON4_INIT)  EBU_BUSCON4.U = __EBU_BUSCON4_VALUE;
; ..\cstart.c	   708  #endif
; ..\cstart.c	   709  #if defined EBU_BUSCON5 && defined __EBU_BUSCON5_VALUE
; ..\cstart.c	   710          if(__EBU_BUSCON5_INIT)  EBU_BUSCON5.U = __EBU_BUSCON5_VALUE;
; ..\cstart.c	   711  #endif
; ..\cstart.c	   712  #if defined EBU_BUSCON6 && defined __EBU_BUSCON6_VALUE
; ..\cstart.c	   713          if(__EBU_BUSCON6_INIT)  EBU_BUSCON6.U = __EBU_BUSCON6_VALUE;
; ..\cstart.c	   714  #endif
; ..\cstart.c	   715  #if defined EBU_EMUAS && defined __EBU_EMUAS_VALUE
; ..\cstart.c	   716          if(__EBU_EMUAS_INIT)  EBU_EMUAS.U = __EBU_EMUAS_VALUE;
; ..\cstart.c	   717  #endif
; ..\cstart.c	   718  #if defined EBU_EMUBAP && defined __EBU_EMUBAP_VALUE
; ..\cstart.c	   719          if(__EBU_EMUBAP_INIT)  EBU_EMUBAP.U = __EBU_EMUBAP_VALUE;
; ..\cstart.c	   720  #endif
; ..\cstart.c	   721  #if defined EBU_EMUBC && defined __EBU_EMUBC_VALUE
; ..\cstart.c	   722          if(__EBU_EMUBC_INIT)  EBU_EMUBC.U = __EBU_EMUBC_VALUE;
; ..\cstart.c	   723  #endif
; ..\cstart.c	   724  #if defined EBU_EMUCON && defined __EBU_EMUCON_VALUE
; ..\cstart.c	   725          if(__EBU_EMUCON_INIT)  EBU_EMUCON.U = __EBU_EMUCON_VALUE;
; ..\cstart.c	   726  #endif
; ..\cstart.c	   727  #if defined EBU_EMUOVL && defined __EBU_EMUOVL_VALUE
; ..\cstart.c	   728          if(__EBU_EMUOVL_INIT)  EBU_EMUOVL.U = __EBU_EMUOVL_VALUE;
; ..\cstart.c	   729  #endif
; ..\cstart.c	   730  #if defined EBU_SDRMCON0 && defined __EBU_SDRMCON0_VALUE
; ..\cstart.c	   731          if(__EBU_SDRMCON0_INIT)  EBU_SDRMCON0.U = __EBU_SDRMCON0_VALUE;
; ..\cstart.c	   732  #endif
; ..\cstart.c	   733  #if defined EBU_SDRMOD0 && defined __EBU_SDRMOD0_VALUE
; ..\cstart.c	   734          if(__EBU_SDRMOD0_INIT)  EBU_SDRMOD0.U = __EBU_SDRMOD0_VALUE;
; ..\cstart.c	   735  #endif
; ..\cstart.c	   736  #if defined EBU_SDRMREF0 && defined __EBU_SDRMREF0_VALUE
; ..\cstart.c	   737          if(__EBU_SDRMREF0_INIT)  EBU_SDRMREF0.U = __EBU_SDRMREF0_VALUE;
; ..\cstart.c	   738  #endif
; ..\cstart.c	   739  #if defined EBU_SDRMCON1 && defined __EBU_SDRMCON1_VALUE
; ..\cstart.c	   740          if(__EBU_SDRMCON1_INIT)  EBU_SDRMCON1.U = __EBU_SDRMCON1_VALUE;
; ..\cstart.c	   741  #endif
; ..\cstart.c	   742  #if defined EBU_SDRMOD1 && defined __EBU_SDRMOD1_VALUE
; ..\cstart.c	   743          if(__EBU_SDRMOD1_INIT)  EBU_SDRMOD1.U = __EBU_SDRMOD1_VALUE;
; ..\cstart.c	   744  #endif
; ..\cstart.c	   745  #if defined EBU_SDRMREF1 && defined __EBU_SDRMREF1_VALUE
; ..\cstart.c	   746          if(__EBU_SDRMREF1_INIT)  EBU_SDRMREF1.U = __EBU_SDRMREF1_VALUE;
; ..\cstart.c	   747  #endif
; ..\cstart.c	   748  #if defined CBS_MCDBBS && defined __CBS_MCDBBS_VALUE
; ..\cstart.c	   749          if(__CBS_MCDBBS_INIT)  CBS_MCDBBS .U = __CBS_MCDBBS_VALUE;
; ..\cstart.c	   750  #endif
; ..\cstart.c	   751  #if defined SBCU_CON && defined __SBCU_CON_VALUE
; ..\cstart.c	   752          if(__SBCU_CON_INIT)  SBCU_CON.U = __SBCU_CON_VALUE;
; ..\cstart.c	   753  #endif
; ..\cstart.c	   754  #if defined EBU_BUSRAP1 && defined __EBU_BUSRAP1_VALUE
; ..\cstart.c	   755          if(__EBU_BUSRAP1_INIT)  EBU_BUSRAP1.U = __EBU_BUSRAP1_VALUE;
; ..\cstart.c	   756  #endif
; ..\cstart.c	   757  #if defined EBU_BUSRAP0 && defined __EBU_BUSRAP0_VALUE
; ..\cstart.c	   758          if(__EBU_BUSRAP0_INIT)  EBU_BUSRAP0.U = __EBU_BUSRAP0_VALUE;
; ..\cstart.c	   759  #endif
; ..\cstart.c	   760  #if defined EBU_BUSRAP2 && defined __EBU_BUSRAP2_VALUE
; ..\cstart.c	   761          if(__EBU_BUSRAP2_INIT)  EBU_BUSRAP2.U = __EBU_BUSRAP2_VALUE;
; ..\cstart.c	   762  #endif
; ..\cstart.c	   763  #if defined EBU_BUSRAP3 && defined __EBU_BUSRAP3_VALUE
; ..\cstart.c	   764          if(__EBU_BUSRAP3_INIT)  EBU_BUSRAP3.U = __EBU_BUSRAP3_VALUE;
; ..\cstart.c	   765  #endif
; ..\cstart.c	   766  #if defined EBU_BUSRCON0 && defined __EBU_BUSRCON0_VALUE
; ..\cstart.c	   767          if(__EBU_BUSRCON0_INIT)  EBU_BUSRCON0.U = __EBU_BUSRCON0_VALUE;
; ..\cstart.c	   768  #endif
; ..\cstart.c	   769  #if defined EBU_BUSRCON1 && defined __EBU_BUSRCON1_VALUE
; ..\cstart.c	   770          if(__EBU_BUSRCON1_INIT)  EBU_BUSRCON1.U = __EBU_BUSRCON1_VALUE;
; ..\cstart.c	   771  #endif
; ..\cstart.c	   772  #if defined EBU_BUSRCON2 && defined __EBU_BUSRCON2_VALUE
; ..\cstart.c	   773          if(__EBU_BUSRCON2_INIT)  EBU_BUSRCON2.U = __EBU_BUSRCON2_VALUE;
; ..\cstart.c	   774  #endif
; ..\cstart.c	   775  #if defined EBU_BUSRCON3 && defined __EBU_BUSRCON3_VALUE
; ..\cstart.c	   776          if(__EBU_BUSRCON3_INIT)  EBU_BUSRCON3.U = __EBU_BUSRCON3_VALUE;
; ..\cstart.c	   777  #endif
; ..\cstart.c	   778  #if defined EBU_BUSWAP0 && defined __EBU_BUSWAP0_VALUE
; ..\cstart.c	   779          if(__EBU_BUSWAP0_INIT)  EBU_BUSWAP0.U = __EBU_BUSWAP0_VALUE;
; ..\cstart.c	   780  #endif
; ..\cstart.c	   781  #if defined EBU_BUSWAP1 && defined __EBU_BUSWAP1_VALUE
; ..\cstart.c	   782          if(__EBU_BUSWAP1_INIT)  EBU_BUSWAP1.U = __EBU_BUSWAP1_VALUE;
; ..\cstart.c	   783  #endif
; ..\cstart.c	   784  #if defined EBU_BUSWAP2 && defined __EBU_BUSWAP2_VALUE
; ..\cstart.c	   785          if(__EBU_BUSWAP2_INIT)  EBU_BUSWAP2.U = __EBU_BUSWAP2_VALUE;
; ..\cstart.c	   786  #endif
; ..\cstart.c	   787  #if defined EBU_BUSWAP3 && defined __EBU_BUSWAP3_VALUE
; ..\cstart.c	   788          if(__EBU_BUSWAP3_INIT)  EBU_BUSWAP3.U = __EBU_BUSWAP3_VALUE;
; ..\cstart.c	   789  #endif
; ..\cstart.c	   790  #if defined EBU_BUSWCON0 && defined __EBU_BUSWCON0_VALUE
; ..\cstart.c	   791          if(__EBU_BUSWCON0_INIT)  EBU_BUSWCON0.U = __EBU_BUSWCON0_VALUE;
; ..\cstart.c	   792  #endif
; ..\cstart.c	   793  #if defined EBU_BUSWCON1 && defined __EBU_BUSWCON1_VALUE
; ..\cstart.c	   794          if(__EBU_BUSWCON1_INIT)  EBU_BUSWCON1.U = __EBU_BUSWCON1_VALUE;
; ..\cstart.c	   795  #endif
; ..\cstart.c	   796  #if defined EBU_BUSWCON2 && defined __EBU_BUSWCON2_VALUE
; ..\cstart.c	   797          if(__EBU_BUSWCON2_INIT)  EBU_BUSWCON2.U = __EBU_BUSWCON2_VALUE;
; ..\cstart.c	   798  #endif
; ..\cstart.c	   799  #if defined EBU_BUSWCON3 && defined __EBU_BUSWCON3_VALUE
; ..\cstart.c	   800          if(__EBU_BUSWCON3_INIT)  EBU_BUSWCON3.U = __EBU_BUSWCON3_VALUE;
; ..\cstart.c	   801  #endif
; ..\cstart.c	   802  #if defined EBU_EXTBOOT && defined __EBU_EXTBOOT_VALUE
; ..\cstart.c	   803          if(__EBU_EXTBOOT_INIT)  EBU_EXTBOOT.U = __EBU_EXTBOOT_VALUE;
; ..\cstart.c	   804  #endif
; ..\cstart.c	   805  #if defined EBU_MODCON && defined __EBU_MODCON_VALUE
; ..\cstart.c	   806          if(__EBU_MODCON_INIT)  EBU_MODCON.U = __EBU_MODCON_VALUE;
; ..\cstart.c	   807  #endif
; ..\cstart.c	   808  #if defined EBU_DDRNCON && defined __EBU_DDRNCON_VALUE
; ..\cstart.c	   809          if(__EBU_DDRNCON_INIT)  EBU_DDRNCON.U = __EBU_DDRNCON_VALUE;
; ..\cstart.c	   810  #endif
; ..\cstart.c	   811  #if defined EBU_DDRNMOD && defined __EBU_DDRNMOD_VALUE
; ..\cstart.c	   812          if(__EBU_DDRNMOD_INIT)  EBU_DDRNMOD.U = __EBU_DDRNMOD_VALUE;
; ..\cstart.c	   813  #endif
; ..\cstart.c	   814  #if defined EBU_DDRNMOD2 && defined __EBU_DDRNMOD2_VALUE
; ..\cstart.c	   815          if(__EBU_DDRNMOD2_INIT)  EBU_DDRNMOD2.U = __EBU_DDRNMOD2_VALUE;
; ..\cstart.c	   816  #endif
; ..\cstart.c	   817  #if defined EBU_DDRNPRLD && defined __EBU_DDRNPRLD_VALUE
; ..\cstart.c	   818          if(__EBU_DDRNPRLD_INIT)  EBU_DDRNPRLD.U = __EBU_DDRNPRLD_VALUE;
; ..\cstart.c	   819  #endif
; ..\cstart.c	   820  #if defined EBU_DDRNTAG0 && defined __EBU_DDRNTAG0_VALUE
; ..\cstart.c	   821          if(__EBU_DDRNTAG0_INIT)  EBU_DDRNTAG0.U = __EBU_DDRNTAG0_VALUE;
; ..\cstart.c	   822  #endif
; ..\cstart.c	   823  #if defined EBU_DDRNTAG1 && defined __EBU_DDRNTAG1_VALUE
; ..\cstart.c	   824          if(__EBU_DDRNTAG1_INIT)  EBU_DDRNTAG1.U = __EBU_DDRNTAG1_VALUE;
; ..\cstart.c	   825  #endif
; ..\cstart.c	   826  #if defined EBU_DDRNTAG2 && defined __EBU_DDRNTAG2_VALUE
; ..\cstart.c	   827          if(__EBU_DDRNTAG2_INIT)  EBU_DDRNTAG2.U = __EBU_DDRNTAG2_VALUE;
; ..\cstart.c	   828  #endif
; ..\cstart.c	   829  #if defined EBU_DDRNTAG3 && defined __EBU_DDRNTAG3_VALUE
; ..\cstart.c	   830          if(__EBU_DDRNTAG3_INIT)  EBU_DDRNTAG3.U = __EBU_DDRNTAG3_VALUE;
; ..\cstart.c	   831  #endif
; ..\cstart.c	   832  #if defined EBU_DLLCON && defined __EBU_DLLCON_VALUE
; ..\cstart.c	   833          if(__EBU_DLLCON_INIT)  EBU_DLLCON.U = __EBU_DLLCON_VALUE;
; ..\cstart.c	   834  #endif
; ..\cstart.c	   835  #if defined EBU_SDRMCON && defined __EBU_SDRMCON_VALUE
; ..\cstart.c	   836          if(__EBU_SDRMCON_INIT)  EBU_SDRMCON.U = __EBU_SDRMCON_VALUE;
; ..\cstart.c	   837  #endif
; ..\cstart.c	   838  #if defined EBU_SDRMOD && defined __EBU_SDRMOD_VALUE
; ..\cstart.c	   839          if(__EBU_SDRMOD_INIT)  EBU_SDRMOD.U = __EBU_SDRMOD_VALUE;
; ..\cstart.c	   840  #endif
; ..\cstart.c	   841  #if defined EBU_SDRMREF && defined __EBU_SDRMREF_VALUE
; ..\cstart.c	   842          if(__EBU_SDRMREF_INIT)  EBU_SDRMREF.U = __EBU_SDRMREF_VALUE;
; ..\cstart.c	   843  #endif
; ..\cstart.c	   844  #if defined EBU_SDRSTAT && defined __EBU_SDRSTAT_VALUE
; ..\cstart.c	   845          if(__EBU_SDRSTAT_INIT)  EBU_SDRSTAT.U = __EBU_SDRSTAT_VALUE;
; ..\cstart.c	   846  #endif
; ..\cstart.c	   847  
; ..\cstart.c	   848          /*
; ..\cstart.c	   849           * Inititialize global address registers a0/a1 to support
; ..\cstart.c	   850           * __a0/__a1 storage qualifiers of the C compiler.
; ..\cstart.c	   851           */
; ..\cstart.c	   852  #if __A0A1_INIT
; ..\cstart.c	   853          void * a0 = _SMALL_DATA_;        
; ..\cstart.c	   854          __asm( "mov.aa\ta0,%0"::"a"(a0) );
; ..\cstart.c	   855  
; ..\cstart.c	   856          void * a1 = _LITERAL_DATA_;        
; ..\cstart.c	   857          __asm( "mov.aa\ta1,%0"::"a"(a1) );
; ..\cstart.c	   858  #endif
; ..\cstart.c	   859  
; ..\cstart.c	   860          /*
; ..\cstart.c	   861           * Inititialize global address registers a8/a9 to support
; ..\cstart.c	   862           * __a8/__a9 storage qualifiers of the C compiler. A8 and A9
; ..\cstart.c	   863           * are reserved for OS use, or for application use in cases 
; ..\cstart.c	   864           * where the application ans OS are tightly coupled.
; ..\cstart.c	   865           */
; ..\cstart.c	   866  #if __A8A9_INIT
; ..\cstart.c	   867          void * a8 = _A8_DATA_;        
; ..\cstart.c	   868          __asm( "mov.aa\ta8,%0"::"a"(a8) );
; ..\cstart.c	   869  
; ..\cstart.c	   870          void * a9 = _A9_DATA_;        
; ..\cstart.c	   871          __asm( "mov.aa\ta9,%0"::"a"(a9) );
; ..\cstart.c	   872  #endif
; ..\cstart.c	   873          
; ..\cstart.c	   874          /* Setup the context save area linked list. */
; ..\cstart.c	   875  #if __CSA_INIT
; ..\cstart.c	   876          
; ..\cstart.c	   877  #  if !__CPU_TC051_INITIAL__
; ..\cstart.c	   878  #  define MAX_NR_OF_CSA_AREAS     1
; ..\cstart.c	   879  extern int _lc_ub_csa_01[][16];    /* context save area 1 begin */
; ..\cstart.c	   880  extern int _lc_ue_csa_01[][16];    /* context save area 1 end   */
; ..\cstart.c	   881  static __far int (* const csa_area_begin[])[16] = { _lc_ub_csa_01 }; 
; ..\cstart.c	   882  static __far int (* const csa_area_end[])[16]   = { _lc_ue_csa_01 };
; ..\cstart.c	   883  #  else
; ..\cstart.c	   884  #  define MAX_NR_OF_CSA_AREAS     3
; ..\cstart.c	   885  extern int _lc_ub_csa_01[][16];    /* context save area 1 begin */
; ..\cstart.c	   886  extern int _lc_ue_csa_01[][16];    /* context save area 1 end   */
; ..\cstart.c	   887  extern int _lc_ub_csa_02[][16];    /* context save area 2 begin */
; ..\cstart.c	   888  extern int _lc_ue_csa_02[][16];    /* context save area 2 end   */
; ..\cstart.c	   889  extern int _lc_ub_csa_03[][16];    /* context save area 3 begin */
; ..\cstart.c	   890  extern int _lc_ue_csa_03[][16];    /* context save area 3 end   */
; ..\cstart.c	   891  static __far int (* const csa_area_begin[])[16] = { _lc_ub_csa_01, _lc_ub_csa_02, _lc_ub_csa_03 };        
; ..\cstart.c	   892  static __far int (* const csa_area_end[])[16]   = { _lc_ue_csa_01, _lc_ue_csa_02, _lc_ue_csa_03 };
; ..\cstart.c	   893  #  endif
; ..\cstart.c	   894  
; ..\cstart.c	   895          int  i, k;
; ..\cstart.c	   896          int  no_of_csas;
; ..\cstart.c	   897          int * csa;
; ..\cstart.c	   898          unsigned int  seg_nr, seg_idx, pcxi_val=0;
; ..\cstart.c	   899          _Bool first=true;
; ..\cstart.c	   900          
; ..\cstart.c	   901          for (i=0; i < MAX_NR_OF_CSA_AREAS; i++)
; ..\cstart.c	   902          {
; ..\cstart.c	   903                  /* first calculate nr of CSAs in this area */
; ..\cstart.c	   904                  no_of_csas = csa_area_end[i] - csa_area_begin[i]; 
; ..\cstart.c	   905                  
; ..\cstart.c	   906                  for (k=0; k < no_of_csas; k++)
; ..\cstart.c	   907                  {
; ..\cstart.c	   908                          csa = csa_area_begin[i][k];
; ..\cstart.c	   909                          /* Store null pointer in last CSA (= very first time!) */
; ..\cstart.c	   910                          *csa = pcxi_val;                        
; ..\cstart.c	   911  
; ..\cstart.c	   912                          seg_nr  = (((unsigned int)csa >> 28) & 0xf) << 16;
; ..\cstart.c	   913                          seg_idx = (((unsigned int)csa >> 6) & 0xffff);
; ..\cstart.c	   914                          pcxi_val = seg_nr | seg_idx;
; ..\cstart.c	   915                          if (first)
; ..\cstart.c	   916                          {
; ..\cstart.c	   917                                  first = false;                                
; ..\cstart.c	   918                                  __mtcr(LCX, pcxi_val);
; ..\cstart.c	   919                          }                        
; ..\cstart.c	   920                  }
; ..\cstart.c	   921                  __mtcr(FCX, pcxi_val);
; ..\cstart.c	   922          }
; ..\cstart.c	   923  #endif
; ..\cstart.c	   924          
; ..\cstart.c	   925          /*
; ..\cstart.c	   926           * PMU_TC.004 workaround:
; ..\cstart.c	   927           * The split mode is disabled on the LMB bus to workaround.
; ..\cstart.c	   928           */
; ..\cstart.c	   929  #if __PMU_TC004_INITIAL__  && defined LFI_CON
; ..\cstart.c	   930          LFI_CON.U &= 0xfffffffe;        
; ..\cstart.c	   931  #endif
; ..\cstart.c	   932          
; ..\cstart.c	   933          /*
; ..\cstart.c	   934           * Initialize and clear C variables.
; ..\cstart.c	   935           */
; ..\cstart.c	   936  #if __C_INIT
; ..\cstart.c	   937          _c_init();      /* initialize data */
; ..\cstart.c	   938  #endif  
; ..\cstart.c	   939  
; ..\cstart.c	   940          /*
; ..\cstart.c	   941           * initialize __clocks_per_sec,
; ..\cstart.c	   942           * the oscillator frequency is defined by __fOSC.
; ..\cstart.c	   943           */
; ..\cstart.c	   944  #if __CLOCKS_PER_SEC_INIT
; ..\cstart.c	   945          setclockpersec();
; ..\cstart.c	   946  #endif  
; ..\cstart.c	   947  
; ..\cstart.c	   948          /* initialize profiling if required 
; ..\cstart.c	   949           */        
; ..\cstart.c	   950  #if __PROF_ENABLE__
; ..\cstart.c	   951          __prof_init();
; ..\cstart.c	   952  #endif
; ..\cstart.c	   953  
; ..\cstart.c	   954          /*
; ..\cstart.c	   955           * Call a user function called _endinit() within one can initialize the 
; ..\cstart.c	   956           * registers protected via the EndInit feature.
; ..\cstart.c	   957           * Beware that protected registers are unlocked 
; ..\cstart.c	   958           * for the duration of the Time-out Period only!
; ..\cstart.c	   959           */
; ..\cstart.c	   960  #ifdef _CALL_ENDINIT
; ..\cstart.c	   961          endinit_set(_ENDINIT_DISABLE);  /* disable the write-protection */
; ..\cstart.c	   962          _endinit();        
; ..\cstart.c	   963          endinit_set(_ENDINIT_ENABLE);    /* enable the write-protection  */
; ..\cstart.c	   964  #endif
; ..\cstart.c	   965          
; ..\cstart.c	   966          /*
; ..\cstart.c	   967           * Call a user function before starting main().
; ..\cstart.c	   968           */
; ..\cstart.c	   969  #ifdef __CALL_INIT
; ..\cstart.c	   970          _call_init();        
; ..\cstart.c	   971  #endif
; ..\cstart.c	   972  
; ..\cstart.c	   973  #if (  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	   974  #if (__HALT_INIT_TC1 && (__HALT_VALUE_TC1 & 0x2)) || (__HALT_INIT_TC2 && (__HALT_VALUE_TC2 & 0x2))
; ..\cstart.c	   975  #if __C_INIT || __CLOCKS_PER_SEC_INIT || __PROF_ENABLE__ || _CALL_ENDINIT || (defined __CALL_INIT)
; ..\cstart.c	   976          __swapmskw( (unsigned int *)&_tcx_end_c_init, 0x1, 0x1 );       /* tc0 end of initialization */
; ..\cstart.c	   977          /*
; ..\cstart.c	   978           * Before calling main, which has code core association share,
; ..\cstart.c	   979           * wait until all cores have done the global initializations
; ..\cstart.c	   980           * to avoid race conditions on initialized shared global data.
; ..\cstart.c	   981           * Only wait for running cores.
; ..\cstart.c	   982           */
; ..\cstart.c	   983  #if ( defined _REGTC26X_H )
; ..\cstart.c	   984          while ( ( _tcx_end_c_init & 0x7 ) != (1 | ( ( (CPU1_DBGSR.B.HALT & 0x1)==0 ) << 1)) ) ;
; ..\cstart.c	   985  #else
; ..\cstart.c	   986          while ( ( _tcx_end_c_init & 0x7 ) != (1 | ( ( (CPU1_DBGSR.B.HALT & 0x1)==0 ) << 1) | ( ( (CPU2_DBGSR.B.HALT & 0x1)==0 ) << 2)) ) ;
; ..\cstart.c	   987  #endif
; ..\cstart.c	   988  #endif
; ..\cstart.c	   989  #endif
; ..\cstart.c	   990  #endif
; ..\cstart.c	   991          
; ..\cstart.c	   992          /*
; ..\cstart.c	   993           * Call C main program.
; ..\cstart.c	   994           */
; ..\cstart.c	   995  #if __USE_ARGC_ARGV
; ..\cstart.c	   996          exit( main( _argcv( argcv, __ARGCV_BUFSIZE ), (char **)argcv ) );
; ..\cstart.c	   997  #else
; ..\cstart.c	   998          exit( main( 0, NULL ) );                /* argc is 0 */
; ..\cstart.c	   999  #endif
; ..\cstart.c	  1000  
; ..\cstart.c	  1001          /*
; ..\cstart.c	  1002           * Default trap vectors are resolved from the C-library.
; ..\cstart.c	  1003           */
; ..\cstart.c	  1004  #if __BTV_INIT
; ..\cstart.c	  1005  #  if __RESOLVE_TRAP_0
; ..\cstart.c	  1006  #    pragma extern  _trapmmu
; ..\cstart.c	  1007  #  endif
; ..\cstart.c	  1008  #  if __RESOLVE_TRAP_1
; ..\cstart.c	  1009  #    pragma extern  _trapprotection
; ..\cstart.c	  1010  #  endif
; ..\cstart.c	  1011  #  if __RESOLVE_TRAP_2
; ..\cstart.c	  1012  #    pragma extern  _trapinstruction
; ..\cstart.c	  1013  #  endif
; ..\cstart.c	  1014  #  if __RESOLVE_TRAP_3
; ..\cstart.c	  1015  #    pragma extern  _trapcontext
; ..\cstart.c	  1016  #  endif
; ..\cstart.c	  1017  #  if __RESOLVE_TRAP_4
; ..\cstart.c	  1018  #    pragma extern  _trapbus
; ..\cstart.c	  1019  #  endif
; ..\cstart.c	  1020  #  if __RESOLVE_TRAP_5
; ..\cstart.c	  1021  #    pragma extern  _trapassertion
; ..\cstart.c	  1022  #  endif
; ..\cstart.c	  1023  #  if __RESOLVE_TRAP_6
; ..\cstart.c	  1024  #    pragma extern  _trapsystem
; ..\cstart.c	  1025  #  endif
; ..\cstart.c	  1026  #  if __RESOLVE_TRAP_7
; ..\cstart.c	  1027  #    pragma extern  _trapnmi
; ..\cstart.c	  1028  #  endif
; ..\cstart.c	  1029  #endif
; ..\cstart.c	  1030          
; ..\cstart.c	  1031  }
; ..\cstart.c	  1032  
; ..\cstart.c	  1033  /**************************************************************************
; ..\cstart.c	  1034   *
; ..\cstart.c	  1035   * FUNCTION:     endinit_set
; ..\cstart.c	  1036   *
; ..\cstart.c	  1037   * DESCRIPTION:  Sets or Clears the ENDINIT bit in the WDT_CON0 register
; ..\cstart.c	  1038   *               in order to enabled or disable the write-protection for
; ..\cstart.c	  1039   *               registers protected via the EndInit feature
; ..\cstart.c	  1040   *               (ie. BTV, BIV, ISP, PCON0, DCON0).
; ..\cstart.c	  1041   *
; ..\cstart.c	  1042   *************************************************************************/
; ..\cstart.c	  1043  static void inline endinit_set( _endinit_t endinit_value )
; ..\cstart.c	  1044  {
; ..\cstart.c	  1045          unsigned int wdt_con0;
; ..\cstart.c	  1046  
; ..\cstart.c	  1047  #if !(  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	  1048          unsigned int wdt_con1;
; ..\cstart.c	  1049  #endif
; ..\cstart.c	  1050          /*
; ..\cstart.c	  1051           * 1st step: Password access (create password and send to WDT_CON0)
; ..\cstart.c	  1052           */        
; ..\cstart.c	  1053          wdt_con0 = WDT_CON0.U;
	lea	a15,0xf00005f0
	ld.w	d0,[a15]
.L105:

; ..\cstart.c	  1054  #if !(  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	  1055          wdt_con1 = WDT_CON1.U;
; ..\cstart.c	  1056  #endif
; ..\cstart.c	  1057  
; ..\cstart.c	  1058          wdt_con0 &= 0xffffff01;         /* clear WDTLCK, WDTHPW0, WDTHPW1 */
	insert	d15,d0,#0,#1,#7
	ld.w	d1,0xf00005f4
.L107:

; ..\cstart.c	  1059          wdt_con0 |= 0xf0;               /* set WDTHPW1 to 0xf */
	or	d0,d15,#240
.L194:

; ..\cstart.c	  1060  #if (  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	  1061          wdt_con0 |= 0x1;                /* 1 must be written to ENDINIT for password access
; ..\cstart.c	  1062                                           * (but this will not actually modify the bit) */
; ..\cstart.c	  1063  #else
; ..\cstart.c	  1064          wdt_con1 &= 0x0c;               /* copy of WDT_CON1.DR and WDT_CON1.IR (d1) */
	and	d15,d1,#12
.L108:

; ..\cstart.c	  1065          wdt_con0 |= wdt_con1;           /* HPW0 is WDT_CON1.DR | WDT_CON1.IR */
; ..\cstart.c	  1066  #endif
; ..\cstart.c	  1067          WDT_CON0.U = wdt_con0;
	or	d0,d15
	st.w	[a15],d0
.L195:

; ..\cstart.c	  1068  
; ..\cstart.c	  1069          /*
; ..\cstart.c	  1070           * 2nd step: Modify access, set the bit ENDINIT to 1 or 0 to allow access to
; ..\cstart.c	  1071           *           registers: WDT_CON1, BTV, BIV, ISP and mod_CLC
; ..\cstart.c	  1072           */
; ..\cstart.c	  1073          wdt_con0 &= 0xfffffff0;         /* clear WDTHPW0, WDTLCK, ENDINIT  */
; ..\cstart.c	  1074          wdt_con0 |= 0x02 | endinit_value;       /* WDTHPW0=0, WDTLCK=1, ENDINIT=0 */
	insert	d15,d0,#2,#0,#4
.L106:

; ..\cstart.c	  1075          __isync();
	isync
.L196:

; ..\cstart.c	  1076          WDT_CON0.U = wdt_con0;          
	st.w	[a15],d15
.L197:

; ..\cstart.c	  1077          WDT_CON0.U;                     /* read is required */
	ld.w	d15,[a15]
.L94:
	ret
.L93:
	
___endinit_clear_function_end:
	.size	_endinit_clear,___endinit_clear_function_end-_endinit_clear
.L35:
	; End of function
	
	.sdecl	'.text.cstart._endinit_set',code,cluster('_endinit_set')
	.sect	'.text.cstart._endinit_set'
	.align	2
	
	.global	_endinit_set
; Function _endinit_set
.L8:
_endinit_set:	.type	func
	lea	a15,0xf00005f0
	ld.w	d0,[a15]
.L109:
	insert	d15,d0,#0,#1,#7
	ld.w	d1,0xf00005f4
.L111:
	or	d0,d15,#240
.L202:
	and	d15,d1,#12
.L112:
	or	d0,d15
	st.w	[a15],d0
.L203:
	insert	d15,d0,#3,#0,#4
.L110:
	isync
.L204:
	st.w	[a15],d15
.L205:
	ld.w	d15,[a15]
.L99:
	ret
.L98:
	
___endinit_set_function_end:
	.size	_endinit_set,___endinit_set_function_end-_endinit_set
.L40:
	; End of function
	
	.sdecl	'.text.libc.reset',code,cluster('_START')
	.sect	'.text.libc.reset'
	.align	2
	
	.global	_START
; Function _START
.L10:
_START:	.type	func
	j	__init_sp
.L103:
	
___START_function_end:
	.size	_START,___START_function_end-_START
.L45:
	; End of function
	
	.sdecl	'.text.cstart.__init_sp',code,cluster('__init_sp')
	.sect	'.text.cstart.__init_sp'
	.align	2
	
; Function __init_sp
.L12:
__init_sp:	.type	func
	movh.a	a15,#@his(_lc_ue_ustack)
	lea	a15,[a15]@los(_lc_ue_ustack)
	mov.d	d15,a15
.L148:
	insert	d15,d15,#0,#0,#3
.L149:
	mov.a	sp,d15
.L150:
	j	_start
.L53:
	
____init_sp_function_end:
	.size	__init_sp,____init_sp_function_end-__init_sp
.L25:
	; End of function
	
	.sdecl	'.text.cstart._start',code,cluster('_start')
	.sect	'.text.cstart._start'
	.align	2
	
; Function _start
.L14:
_start:	.type	func
	dsync
.L155:
	mov	d15,#2432
.L156:
	mtcr	#65028,d15
	isync
.L55:
	mfcr	d15,#65024
.L157:
	insert	d15,d15,#0,#0,#20
.L113:
	mtcr	#65024,d15
	isync
.L59:
	lea	a15,0xf00005f0
	ld.w	d0,[a15]
.L118:
	lea	a2,0xf00005f4
	movh.a	a14,#@his(.L217)
	lea	a14,[a14]@los(.L217)
	j	.cocofun_1
.L217:
.L114:
	insert	d15,d0,#2,#0,#4
.L119:
	isync
.L158:
	st.w	[a15],d15
.L159:
	ld.w	d15,[a15]
.L60:
	ld.w	d15,[a2]
.L160:
	or	d15,#8
	st.w	[a2],d15
.L67:
	ld.w	d0,[a15]
.L120:
	movh.a	a14,#@his(.L218)
	lea	a14,[a14]@los(.L218)
	j	.cocofun_1
.L218:
.L122:
	insert	d15,d0,#3,#0,#4
.L121:
	isync
.L161:
	st.w	[a15],d15
.L162:
	ld.w	d15,[a15]
.L68:
	ld.w	d0,[a15]
.L123:
	movh.a	a14,#@his(.L219)
	lea	a14,[a14]@los(.L219)
	j	.cocofun_1
.L219:
.L125:
	insert	d15,d0,#2,#0,#4
.L124:
	isync
.L163:
	st.w	[a15],d15
.L164:
	ld.w	d15,[a15]
.L71:
	movh.a	a4,#@his(_lc_u_trap_tab)
	lea	a4,[a4]@los(_lc_u_trap_tab)
	mov.d	d15,a4
.L165:
	mtcr	#65060,d15
	isync
.L166:
	movh.a	a4,#@his(_lc_u_int_tab)
	lea	a4,[a4]@los(_lc_u_int_tab)
	mov.d	d15,a4
.L167:
	mtcr	#65056,d15
	isync
.L74:
	movh.a	a4,#@his(_lc_ue_istack)
	lea	a4,[a4]@los(_lc_ue_istack)
	mov.d	d15,a4
.L168:
	insert	d15,d15,#0,#0,#3
.L169:
	mtcr	#65064,d15
	isync
.L170:
	mov	d15,#0
	movh.a	a4,#63616
	st.w	[a4]@los(0xf87ffd10),d15
.L171:
	mov	d15,#644
.L172:
	addih	d15,d15,#644
	st.w	[a4]@los(0xf87ffd18),d15
.L173:
	mov	d15,#2050
.L174:
	addih	d15,d15,#2050
	st.w	[a4]@los(0xf87ffc10),d15
.L75:
	ld.w	d0,[a15]
.L126:
	movh.a	a14,#@his(.L220)
	lea	a14,[a14]@los(.L220)
	j	.cocofun_1
.L220:
.L128:
	insert	d15,d0,#3,#0,#4
.L127:
	isync
.L175:
	st.w	[a15],d15
.L176:
	ld.w	d15,[a15]
.L76:
	movh.a	a15,#@his(_SMALL_DATA_)
	lea	a15,[a15]@los(_SMALL_DATA_)
.L177:
	mov.aa	a0,a15
.L79:
	movh.a	a15,#@his(_LITERAL_DATA_)
	lea	a15,[a15]@los(_LITERAL_DATA_)
.L178:
	mov.aa	a1,a15
.L80:
	movh.a	a15,#@his(_A8_DATA_)
	lea	a15,[a15]@los(_A8_DATA_)
.L179:
	mov.aa	a8,a15
.L81:
	movh.a	a15,#@his(_A9_DATA_)
	lea	a15,[a15]@los(_A9_DATA_)
.L180:
	mov.aa	a9,a15
.L82:
	mov	d0,#0
.L129:
	mov	d15,#1
	movh.a	a15,#@his(_lc_ub_csa_01)
.L131:
	lea	a15,[a15]@los(_lc_ub_csa_01)
.L181:
	movh.a	a2,#@his(_lc_ue_csa_01)
	lea	a2,[a2]@los(_lc_ue_csa_01)
.L182:
	sub.a	a2,a2,a15
	mov.d	d1,a2
.L132:
	sha	d1,#-6
.L183:
	mov	d2,d0
.L134:
	j	.L2
.L3:
	mov.aa	a2,a15
.L135:
	mov.d	d3,a2
.L136:
	st.w	[a2],d0
.L184:
	sh	d0,d3,#-28
	lea	a15,[a15]64
.L130:
	sh	d0,d0,#16
.L138:
	extr.u	d3,d3,#6,#16
.L137:
	or	d0,d3
.L139:
	jeq	d15,#0,.L4				; predicted taken
.L185:
	mov	d15,#0
.L186:
	mtcr	#65084,d0
	isync
.L4:
	add	d2,#1
.L2:
	jlt	d2,d1,.L3				; predicted taken
.L187:
	mtcr	#65080,d0
	isync
.L188:
	call	_c_init
.L133:
	mov	d4,#0
	mov.a	a4,#0
	call	main
.L189:
	mov	d4,d2
	j	exit
.L54:
	
___start_function_end:
	.size	_start,___start_function_end-_start
.L30:
	; End of function
	
	.sdecl	'.text.cstart..cocofun_1',code,cluster('.cocofun_1')
	.sect	'.text.cstart..cocofun_1'
	.align	2
; Function .cocofun_1
.L16:
.cocofun_1:	.type	func
; Function body .cocofun_1, coco_iter:0
	insert	d15,d0,#0,#1,#7
	ld.w	d1,[a2]
.L115:
	or	d0,d15,#240
.L214:
	and	d15,d1,#12
.L117:
	or	d0,d15
	st.w	[a15],d0
.L116:
	ji	a14
.L50:
	; End of function
	.sdecl	'.rodata.libc.ebu_bootcfg',data,rom,cluster('_EBU_BOOTCFG'),protect
	.sect	'.rodata.libc.ebu_bootcfg'
	.global	_EBU_BOOTCFG
	.align	2
_EBU_BOOTCFG:	.type	object
	.size	_EBU_BOOTCFG,4
	.space	4
	.calls	'_START','__init_sp'
	.calls	'__init_sp','_start'
	.calls	'_start','_c_init'
	.calls	'_start','main'
	.calls	'_start','exit'
	.calls	'_start','.cocofun_1'
	.calls	'_endinit_clear','',0
	.calls	'_endinit_set','',0
	.calls	'_START','',0
	.calls	'__init_sp','',0
	.calls	'_start','',0
	.weak	exit
	.extern	exit
	.extern	_Exit
	.extern	_lc_ue_ustack
	.extern	_lc_ue_istack
	.extern	_lc_u_int_tab
	.extern	_lc_u_trap_tab
	.extern	_SMALL_DATA_
	.extern	_LITERAL_DATA_
	.extern	_A8_DATA_
	.extern	_A9_DATA_
	.extern	_c_init
	.extern	main
	.extern	_lc_ub_csa_01
	.extern	_lc_ue_csa_01
	.extern	_trapmmu
	.extern	_trapprotection
	.extern	_trapinstruction
	.extern	_trapcontext
	.extern	_trapbus
	.extern	_trapassertion
	.extern	_trapsystem
	.extern	_trapnmi
	.calls	'.cocofun_1','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L18:
	.word	1089
	.half	3
	.word	.L19
	.byte	4
.L17:
	.byte	1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Debug\\',0,12,1
	.word	.L20
.L58:
	.byte	2
	.byte	'endinit_set',0,3,1,147,8,20,1,1,3,1,66,9,1,4
	.byte	'_ENDINIT_DISABLE',0,0,4
	.byte	'_ENDINIT_ENABLE',0,1,0
.L61:
	.byte	5
	.byte	'endinit_value',0,1,147,8,44
	.word	149
.L63:
	.byte	6,0,7
	.byte	'__mtcr',0,1,1,1,1
.L83:
	.byte	8
	.byte	'int',0,4,5,9
	.word	229
	.byte	9
	.word	229
	.byte	0,10
	.word	229
	.byte	11
	.byte	'__mfcr',0
	.word	247
	.byte	1,1,1,1,9
	.word	229
	.byte	0,12
	.byte	'__isync',0,1,1,1,1,12
	.byte	'__dsync',0,1,1,1,1,13
	.byte	'exit',0,2,90,33,1,1,1,1,14,2,90,44
	.word	229
	.byte	0,15
	.byte	'_c_init',0,1,48,13,1,1,1,1
.L56:
	.byte	8
	.byte	'unsigned int',0,4,7
.L86:
	.byte	16
	.word	229
.L91:
	.byte	8
	.byte	'_Bool',0,1,2,17
	.word	129
	.byte	18
	.word	192
	.byte	6,0,19
	.byte	'void',0,16
	.word	380
	.byte	20
	.byte	'__prof_adm',0,1,1,1
	.word	386
	.byte	21,1,16
	.word	410
	.byte	20
	.byte	'__codeptr',0,1,1,1
	.word	412
	.byte	22,3,191,19,18,4,23,3,193,19,2,4,8
	.byte	'unsigned int',0,4,7,24
	.byte	'CNT1',0,4
	.word	447
	.byte	12,20,2,35,0,25,4
	.word	447
	.byte	2,18,2,35,0,24
	.byte	'TOS',0,4
	.word	447
	.byte	2,16,2,35,0,24
	.byte	'SRPN',0,4
	.word	447
	.byte	8,8,2,35,0,24
	.byte	'CPPN',0,4
	.word	447
	.byte	8,0,2,35,0,0,26
	.byte	'B',0,4
	.word	441
	.byte	2,35,0,26
	.byte	'I',0,4
	.word	229
	.byte	2,35,0,26
	.byte	'U',0,4
	.word	338
	.byte	2,35,0,0,10
	.word	435
	.byte	20
	.byte	'PCP_GPR6_type',0,3,204,19,3
	.word	572
	.byte	22,3,206,19,18,4,23,3,208,19,2,4,24
	.byte	'Z',0,4
	.word	447
	.byte	1,31,2,35,0,24
	.byte	'N',0,4
	.word	447
	.byte	1,30,2,35,0,24
	.byte	'C',0,4
	.word	447
	.byte	1,29,2,35,0,24
	.byte	'V',0,4
	.word	447
	.byte	1,28,2,35,0,24
	.byte	'CNZ',0,4
	.word	447
	.byte	1,27,2,35,0,24
	.byte	'IEN',0,4
	.word	447
	.byte	1,26,2,35,0,24
	.byte	'CEN',0,4
	.word	447
	.byte	1,25,2,35,0,25,4
	.word	447
	.byte	1,24,2,35,0,24
	.byte	'DPTR',0,4
	.word	447
	.byte	8,16,2,35,0,25,4
	.word	447
	.byte	16,0,2,35,0,0,26
	.byte	'B',0,4
	.word	606
	.byte	2,35,0,26
	.byte	'I',0,4
	.word	229
	.byte	2,35,0,26
	.byte	'U',0,4
	.word	338
	.byte	2,35,0,0,10
	.word	600
	.byte	20
	.byte	'PCP_GPR7_type',0,3,224,19,3
	.word	782
	.byte	27
	.word	380
	.byte	28,0,29
	.byte	'_lc_ue_ustack',0,1,37,19
	.word	810
	.byte	1,1,29
	.byte	'_lc_ue_istack',0,1,38,19
	.word	810
	.byte	1,1,29
	.byte	'_lc_u_int_tab',0,1,39,19
	.word	810
	.byte	1,1,29
	.byte	'_lc_u_trap_tab',0,1,40,19
	.word	810
	.byte	1,1,29
	.byte	'_SMALL_DATA_',0,1,41,19
	.word	810
	.byte	1,1,29
	.byte	'_LITERAL_DATA_',0,1,42,19
	.word	810
	.byte	1,1,29
	.byte	'_A8_DATA_',0,1,43,19
	.word	810
	.byte	1,1,29
	.byte	'_A9_DATA_',0,1,44,19
	.word	810
	.byte	1,1,20
	.byte	'_endinit_t',0,1,70,9
	.word	149
.L104:
	.byte	30
	.word	229
	.byte	31,64
	.word	229
	.byte	32,15,0,27
	.word	1026
	.byte	28,0,29
	.byte	'_lc_ub_csa_01',0,1,239,6,12
	.word	1035
	.byte	1,1,29
	.byte	'_lc_ue_csa_01',0,1,240,6,12
	.word	1035
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L19:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,46,1,3,8,32,13,58,15,59,15,57,15,54,15,39,12,0,0,3,4,1
	.byte	58,15,59,15,57,15,11,15,0,0,4,40,0,3,8,28,13,0,0,5,5,0,3,8,58,15,59,15,57,15,73,19,0,0,6,11,0,0,0,7,46
	.byte	1,3,8,54,15,39,12,63,12,60,12,0,0,8,36,0,3,8,11,15,62,15,0,0,9,5,0,73,19,0,0,10,53,0,73,19,0,0,11,46,1
	.byte	3,8,73,19,54,15,39,12,63,12,60,12,0,0,12,46,0,3,8,54,15,39,12,63,12,60,12,0,0,13,46,1,3,8,58,15,59,15
	.byte	57,15,54,15,39,12,63,12,60,12,0,0,14,5,0,58,15,59,15,57,15,73,19,0,0,15,46,0,3,8,58,15,59,15,57,15,54
	.byte	15,39,12,63,12,60,12,0,0,16,15,0,73,19,0,0,17,46,1,49,19,0,0,18,5,0,49,19,0,0,19,59,0,3,8,0,0,20,22,0
	.byte	3,8,58,15,59,15,57,15,73,19,0,0,21,21,0,54,15,0,0,22,23,1,58,15,59,15,57,15,11,15,0,0,23,19,1,58,15,59
	.byte	15,57,15,11,15,0,0,24,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0,25,13,0,11,15,73,19,13,15,12,15,56,9,0
	.byte	0,26,13,0,3,8,11,15,73,19,56,9,0,0,27,1,1,73,19,0,0,28,33,0,0,0,29,52,0,3,8,58,15,59,15,57,15,73,19,63
	.byte	12,60,12,0,0,30,38,0,73,19,0,0,31,1,1,11,15,73,19,0,0,32,33,0,47,15,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L20:
	.word	.L141-.L140
.L140:
	.half	3
	.word	.L143-.L142
.L142:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1
	.byte	'C:\\Program Files (x86)\\TASKING\\TriCore v4.3r1\\ctc\\include\\',0,0
	.byte	'..\\cstart.c',0,0,0,0
	.byte	'stdlib.h',0,1,0,0
	.byte	'C:\\Program Files (x86)\\TASKING\\TriCore v4.3r1\\ctc\\include\\sfr\\regtc1782.sfr',0,0,0,0,0
.L143:
.L141:
	.sdecl	'.debug_info',debug,cluster('__init_sp')
	.sect	'.debug_info'
.L21:
	.word	174
	.half	3
	.word	.L22
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Debug\\',0,12,1
	.word	.L24,.L23
	.byte	2
	.word	.L17
	.byte	3
	.byte	'__init_sp',0,1,137,1,48,1,1
	.word	.L12,.L53,.L11
	.byte	4
	.word	.L12,.L53
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('__init_sp')
	.sect	'.debug_abbrev'
.L22:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('__init_sp')
	.sect	'.debug_line'
.L23:
	.word	.L145-.L144
.L144:
	.half	3
	.word	.L147-.L146
.L146:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L147:
	.byte	5,42,7,0,5,2
	.word	.L12
	.byte	3,169,1,1,5,57,9
	.half	.L148-.L12
	.byte	1,5,9,9
	.half	.L149-.L148
	.byte	3,1,1,5,15,9
	.half	.L150-.L149
	.byte	3,2,1,5,1,7,9
	.half	.L25-.L150
	.byte	3,1,0,1,1
.L145:
	.sdecl	'.debug_ranges',debug,cluster('__init_sp')
	.sect	'.debug_ranges'
.L24:
	.word	-1,.L12,0,.L25-.L12,0,0
	.sdecl	'.debug_info',debug,cluster('_start')
	.sect	'.debug_info'
.L26:
	.word	718
	.half	3
	.word	.L27
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Debug\\',0,12,1
	.word	.L29,.L28
	.byte	2
	.word	.L17
	.byte	3
	.byte	'_start',0,1,180,1,48,1,1
	.word	.L14,.L54,.L13
	.byte	4
	.word	.L14,.L54
	.byte	4
	.word	.L55,.L54
	.byte	5
	.byte	'pcxi',0,1,237,1,22
	.word	.L56,.L57
	.byte	6
	.word	.L58,.L59,.L60
	.byte	7
	.word	.L61,.L62
	.byte	8
	.word	.L63,.L64
	.byte	5
	.byte	'wdt_con0',0,1,149,8,22
	.word	.L56,.L65
	.byte	5
	.byte	'wdt_con1',0,1,152,8,22
	.word	.L56,.L66
	.byte	0,0,6
	.word	.L58,.L67,.L68
	.byte	7
	.word	.L61,.L62
	.byte	9
	.word	.L63,.L67,.L68
	.byte	5
	.byte	'wdt_con0',0,1,149,8,22
	.word	.L56,.L69
	.byte	5
	.byte	'wdt_con1',0,1,152,8,22
	.word	.L56,.L70
	.byte	0,0,6
	.word	.L58,.L68,.L71
	.byte	7
	.word	.L61,.L62
	.byte	9
	.word	.L63,.L68,.L71
	.byte	5
	.byte	'wdt_con0',0,1,149,8,22
	.word	.L56,.L72
	.byte	5
	.byte	'wdt_con1',0,1,152,8,22
	.word	.L56,.L73
	.byte	0,0,4
	.word	.L74,.L54
	.byte	6
	.word	.L58,.L75,.L76
	.byte	7
	.word	.L61,.L62
	.byte	9
	.word	.L63,.L75,.L76
	.byte	5
	.byte	'wdt_con0',0,1,149,8,22
	.word	.L56,.L77
	.byte	5
	.byte	'wdt_con1',0,1,152,8,22
	.word	.L56,.L78
	.byte	0,0,4
	.word	.L76,.L54
	.byte	4
	.word	.L79,.L54
	.byte	4
	.word	.L80,.L54
	.byte	4
	.word	.L81,.L54
	.byte	4
	.word	.L82,.L54
	.byte	5
	.byte	'k',0,1,255,6,17
	.word	.L83,.L84
	.byte	5
	.byte	'no_of_csas',0,1,128,7,14
	.word	.L83,.L85
	.byte	5
	.byte	'csa',0,1,129,7,15
	.word	.L86,.L87
	.byte	5
	.byte	'seg_nr',0,1,130,7,23
	.word	.L56,.L88
	.byte	5
	.byte	'seg_idx',0,1,130,7,31
	.word	.L56,.L89
	.byte	5
	.byte	'pcxi_val',0,1,130,7,40
	.word	.L56,.L90
	.byte	5
	.byte	'first',0,1,131,7,15
	.word	.L91,.L92
	.byte	0,0,0,0,0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('_start')
	.sect	'.debug_abbrev'
.L27:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,6,29,1,49,16
	.byte	17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,85,6,0,0,9,11,1,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('_start')
	.sect	'.debug_line'
.L28:
	.word	.L152-.L151
.L151:
	.half	3
	.word	.L154-.L153
.L153:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L154:
	.byte	5,16,7,0,5,2
	.word	.L14
	.byte	3,226,1,1,5,21,9
	.half	.L155-.L14
	.byte	3,4,1,5,15,9
	.half	.L156-.L155
	.byte	1,5,35,9
	.half	.L55-.L156
	.byte	3,6,1,5,14,9
	.half	.L157-.L55
	.byte	3,1,1,5,15,9
	.half	.L113-.L157
	.byte	3,1,1,5,28,9
	.half	.L59-.L113
	.byte	3,174,6,1,9
	.half	.L118-.L59
	.byte	3,2,1,5,18,9
	.half	.L114-.L118
	.byte	3,19,1,5,16,9
	.half	.L119-.L114
	.byte	3,1,1,5,20,9
	.half	.L158-.L119
	.byte	3,1,1,5,17,9
	.half	.L159-.L158
	.byte	3,1,1,9
	.half	.L60-.L159
	.byte	3,221,121,1,5,20,9
	.half	.L160-.L60
	.byte	1,5,28,9
	.half	.L67-.L160
	.byte	3,139,6,1,9
	.half	.L120-.L67
	.byte	3,2,1,5,18,9
	.half	.L122-.L120
	.byte	3,19,1,5,16,9
	.half	.L121-.L122
	.byte	3,1,1,5,20,9
	.half	.L161-.L121
	.byte	3,1,1,5,17,9
	.half	.L162-.L161
	.byte	3,1,1,5,28,9
	.half	.L68-.L162
	.byte	3,104,1,9
	.half	.L123-.L68
	.byte	3,2,1,5,18,9
	.half	.L125-.L123
	.byte	3,19,1,5,16,9
	.half	.L124-.L125
	.byte	3,1,1,5,20,9
	.half	.L163-.L124
	.byte	3,1,1,5,17,9
	.half	.L164-.L163
	.byte	3,1,1,5,36,9
	.half	.L71-.L164
	.byte	3,243,121,1,5,15,9
	.half	.L165-.L71
	.byte	1,5,36,9
	.half	.L166-.L165
	.byte	3,25,1,5,15,9
	.half	.L167-.L166
	.byte	1,5,43,9
	.half	.L74-.L167
	.byte	3,11,1,5,58,9
	.half	.L168-.L74
	.byte	1,5,15,9
	.half	.L169-.L168
	.byte	3,1,1,5,43,9
	.half	.L170-.L169
	.byte	3,7,1,5,41,1,5,43,9
	.half	.L171-.L170
	.byte	3,11,1,5,41,9
	.half	.L172-.L171
	.byte	1,9
	.half	.L173-.L172
	.byte	3,16,1,5,39,9
	.half	.L174-.L173
	.byte	1,5,28,9
	.half	.L75-.L174
	.byte	3,174,5,1,9
	.half	.L126-.L75
	.byte	3,2,1,5,18,9
	.half	.L128-.L126
	.byte	3,19,1,5,16,9
	.half	.L127-.L128
	.byte	3,1,1,5,20,9
	.half	.L175-.L127
	.byte	3,1,1,5,17,9
	.half	.L176-.L175
	.byte	3,1,1,5,21,9
	.half	.L76-.L176
	.byte	3,160,126,1,5,9,9
	.half	.L177-.L76
	.byte	3,1,1,5,21,9
	.half	.L79-.L177
	.byte	3,2,1,5,9,9
	.half	.L178-.L79
	.byte	3,1,1,5,21,9
	.half	.L80-.L178
	.byte	3,10,1,5,9,9
	.half	.L179-.L80
	.byte	3,1,1,5,21,9
	.half	.L81-.L179
	.byte	3,2,1,5,9,9
	.half	.L180-.L81
	.byte	3,1,1,5,48,9
	.half	.L82-.L180
	.byte	3,27,1,5,20,9
	.half	.L129-.L82
	.byte	3,1,1,5,53,3,110,1,9
	.half	.L181-.L129
	.byte	3,1,1,5,46,9
	.half	.L182-.L181
	.byte	3,22,1,5,23,9
	.half	.L183-.L182
	.byte	3,2,1,5,41,9
	.half	.L134-.L183
	.byte	1,5,29,9
	.half	.L3-.L134
	.byte	3,2,1,5,51,9
	.half	.L135-.L3
	.byte	3,4,1,5,30,9
	.half	.L136-.L135
	.byte	3,126,1,5,55,9
	.half	.L184-.L136
	.byte	3,2,1,5,44,3,122,1,5,69,9
	.half	.L130-.L184
	.byte	3,6,1,5,61,9
	.half	.L138-.L130
	.byte	3,1,1,5,43,9
	.half	.L137-.L138
	.byte	3,1,1,5,25,9
	.half	.L139-.L137
	.byte	3,1,1,5,39,7,9
	.half	.L185-.L139
	.byte	3,2,1,9
	.half	.L186-.L185
	.byte	3,1,1,5,44,9
	.half	.L4-.L186
	.byte	3,116,1,5,41,9
	.half	.L2-.L4
	.byte	1,5,23,7,9
	.half	.L187-.L2
	.byte	3,15,1,5,16,9
	.half	.L188-.L187
	.byte	3,16,1,5,21,9
	.half	.L133-.L188
	.byte	3,61,1,5,24,1,5,19,9
	.half	.L189-.L133
	.byte	1,5,1,9
	.half	.L30-.L189
	.byte	3,33,0,1,1
.L152:
	.sdecl	'.debug_ranges',debug,cluster('_start')
	.sect	'.debug_ranges'
.L29:
	.word	-1,.L14,0,.L30-.L14,0,0
.L64:
	.word	-1,.L14,.L59-.L14,.L60-.L14,-1,.L16,0,.L50-.L16,0,0
	.sdecl	'.debug_info',debug,cluster('_endinit_clear')
	.sect	'.debug_info'
.L31:
	.word	261
	.half	3
	.word	.L32
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Debug\\',0,12,1
	.word	.L34,.L33
	.byte	2
	.word	.L17
	.byte	3
	.byte	'_endinit_clear',0,1,74,13,1,1,1
	.word	.L6,.L93,.L5
	.byte	4
	.word	.L6,.L93
	.byte	5
	.word	.L58,.L6,.L94
	.byte	6
	.word	.L61,.L95
	.byte	7
	.word	.L63,.L6,.L94
	.byte	8
	.byte	'wdt_con0',0,1,149,8,22
	.word	.L56,.L96
	.byte	8
	.byte	'wdt_con1',0,1,152,8,22
	.word	.L56,.L97
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('_endinit_clear')
	.sect	'.debug_abbrev'
.L32:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,29,1,49,16,17,1,18,1,0,0,6,5,0,49,16,2,6,0,0,7,11
	.byte	1,49,16,17,1,18,1,0,0,8,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('_endinit_clear')
	.sect	'.debug_line'
.L33:
	.word	.L191-.L190
.L190:
	.half	3
	.word	.L193-.L192
.L192:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L193:
	.byte	5,28,7,0,5,2
	.word	.L6
	.byte	3,156,8,1,5,18,9
	.half	.L105-.L6
	.byte	3,5,1,5,28,3,125,1,5,18,9
	.half	.L107-.L105
	.byte	3,4,1,9
	.half	.L194-.L107
	.byte	3,5,1,9
	.half	.L108-.L194
	.byte	3,1,1,5,20,3,2,1,5,18,9
	.half	.L195-.L108
	.byte	3,7,1,5,16,9
	.half	.L106-.L195
	.byte	3,1,1,5,20,9
	.half	.L196-.L106
	.byte	3,1,1,5,17,9
	.half	.L197-.L196
	.byte	3,1,1,5,67,9
	.half	.L94-.L197
	.byte	3,149,120,1,7,9
	.half	.L35-.L94
	.byte	0,1,1
.L191:
	.sdecl	'.debug_ranges',debug,cluster('_endinit_clear')
	.sect	'.debug_ranges'
.L34:
	.word	-1,.L6,0,.L35-.L6,0,0
	.sdecl	'.debug_info',debug,cluster('_endinit_set')
	.sect	'.debug_info'
.L36:
	.word	259
	.half	3
	.word	.L37
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Debug\\',0,12,1
	.word	.L39,.L38
	.byte	2
	.word	.L17
	.byte	3
	.byte	'_endinit_set',0,1,75,13,1,1,1
	.word	.L8,.L98,.L7
	.byte	4
	.word	.L8,.L98
	.byte	5
	.word	.L58,.L8,.L99
	.byte	6
	.word	.L61,.L100
	.byte	7
	.word	.L63,.L8,.L99
	.byte	8
	.byte	'wdt_con0',0,1,149,8,22
	.word	.L56,.L101
	.byte	8
	.byte	'wdt_con1',0,1,152,8,22
	.word	.L56,.L102
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('_endinit_set')
	.sect	'.debug_abbrev'
.L37:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,29,1,49,16,17,1,18,1,0,0,6,5,0,49,16,2,6,0,0,7,11
	.byte	1,49,16,17,1,18,1,0,0,8,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('_endinit_set')
	.sect	'.debug_line'
.L38:
	.word	.L199-.L198
.L198:
	.half	3
	.word	.L201-.L200
.L200:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L201:
	.byte	5,28,7,0,5,2
	.word	.L8
	.byte	3,156,8,1,5,18,9
	.half	.L109-.L8
	.byte	3,5,1,5,28,3,125,1,5,18,9
	.half	.L111-.L109
	.byte	3,4,1,9
	.half	.L202-.L111
	.byte	3,5,1,9
	.half	.L112-.L202
	.byte	3,1,1,5,20,3,2,1,5,18,9
	.half	.L203-.L112
	.byte	3,7,1,5,16,9
	.half	.L110-.L203
	.byte	3,1,1,5,20,9
	.half	.L204-.L110
	.byte	3,1,1,5,17,9
	.half	.L205-.L204
	.byte	3,1,1,5,66,9
	.half	.L99-.L205
	.byte	3,150,120,1,7,9
	.half	.L40-.L99
	.byte	0,1,1
.L199:
	.sdecl	'.debug_ranges',debug,cluster('_endinit_set')
	.sect	'.debug_ranges'
.L39:
	.word	-1,.L8,0,.L40-.L8,0,0
	.sdecl	'.debug_info',debug,cluster('_START')
	.sect	'.debug_info'
.L41:
	.word	171
	.half	3
	.word	.L42
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Debug\\',0,12,1
	.word	.L44,.L43
	.byte	2
	.word	.L17
	.byte	3
	.byte	'_START',0,1,115,6,1,1,1
	.word	.L10,.L103,.L9
	.byte	4
	.word	.L10,.L103
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('_START')
	.sect	'.debug_abbrev'
.L42:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('_START')
	.sect	'.debug_line'
.L43:
	.word	.L207-.L206
.L206:
	.half	3
	.word	.L209-.L208
.L208:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L209:
	.byte	5,18,7,0,5,2
	.word	.L10
	.byte	3,244,0,1,5,1,7,9
	.half	.L45-.L10
	.byte	3,1,0,1,1
.L207:
	.sdecl	'.debug_ranges',debug,cluster('_START')
	.sect	'.debug_ranges'
.L44:
	.word	-1,.L10,0,.L45-.L10,0,0
	.sdecl	'.debug_info',debug,cluster('.cocofun_1')
	.sect	'.debug_info'
.L46:
	.word	164
	.half	3
	.word	.L47
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Debug\\',0,12,1
	.word	.L49,.L48
	.byte	2
	.word	.L17
	.byte	3
	.byte	'.cocofun_1',0,1,180,1,48,1
	.word	.L16,.L50,.L15
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('.cocofun_1')
	.sect	'.debug_abbrev'
.L47:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,0,3,8,58,15,59,15,57,15,54,15
	.byte	17,1,18,1,64,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('.cocofun_1')
	.sect	'.debug_line'
.L48:
	.word	.L211-.L210
.L210:
	.half	3
	.word	.L213-.L212
.L212:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L213:
	.byte	5,18,7,0,5,2
	.word	.L16
	.byte	3,161,8,1,5,28,3,125,1,5,18,9
	.half	.L115-.L16
	.byte	3,4,1,9
	.half	.L214-.L115
	.byte	3,5,1,9
	.half	.L117-.L214
	.byte	3,1,1,5,20,3,2,1,9
	.half	.L50-.L117
	.byte	0,1,1,5,18,0,5,2
	.word	.L16
	.byte	3,161,8,1,5,28,3,125,1,5,18,9
	.half	.L115-.L16
	.byte	3,4,1,9
	.half	.L214-.L115
	.byte	3,5,1,9
	.half	.L117-.L214
	.byte	3,1,1,5,20,3,2,1,9
	.half	.L50-.L117
	.byte	0,1,1,5,18,0,5,2
	.word	.L16
	.byte	3,161,8,1,5,28,3,125,1,5,18,9
	.half	.L115-.L16
	.byte	3,4,1,9
	.half	.L214-.L115
	.byte	3,5,1,9
	.half	.L117-.L214
	.byte	3,1,1,5,20,3,2,1,9
	.half	.L50-.L117
	.byte	0,1,1,5,18,0,5,2
	.word	.L16
	.byte	3,161,8,1,5,28,3,125,1,5,18,9
	.half	.L115-.L16
	.byte	3,4,1,9
	.half	.L214-.L115
	.byte	3,5,1,9
	.half	.L117-.L214
	.byte	3,1,1,5,20,3,2,1,9
	.half	.L50-.L117
	.byte	0,1,1
.L211:
	.sdecl	'.debug_ranges',debug,cluster('.cocofun_1')
	.sect	'.debug_ranges'
.L49:
	.word	-1,.L16,0,.L50-.L16,0,0
	.sdecl	'.debug_info',debug,cluster('_EBU_BOOTCFG')
	.sect	'.debug_info'
.L51:
	.word	156
	.half	3
	.word	.L52
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\work\\Microvast\\OTA\\Boot\\BMU_BOOT_1.9\\BMU_BOOT\\Debug\\',0,12,1,2
	.word	.L17
	.byte	3
	.byte	'_EBU_BOOTCFG',0,1,128,1,17
	.word	.L104
	.byte	1,5,3
	.word	_EBU_BOOTCFG
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('_EBU_BOOTCFG')
	.sect	'.debug_abbrev'
.L52:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_loc',debug,cluster('.cocofun_1')
	.sect	'.debug_loc'
.L15:
	.word	-1,.L16,0,.L50-.L16
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_START')
	.sect	'.debug_loc'
.L9:
	.word	-1,.L10,0,.L103-.L10
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('__init_sp')
	.sect	'.debug_loc'
.L11:
	.word	-1,.L12,0,.L53-.L12
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_endinit_clear')
	.sect	'.debug_loc'
.L5:
	.word	-1,.L6,0,.L93-.L6
	.half	2
	.byte	138,0
	.word	0,0
.L95:
	.word	0,0
.L96:
	.word	-1,.L6,.L105-.L6,.L106-.L6
	.half	5
	.byte	144,32,157,32,0
	.word	.L106-.L6,.L94-.L6
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L97:
	.word	-1,.L6,.L107-.L6,.L108-.L6
	.half	5
	.byte	144,32,157,32,32
	.word	.L108-.L6,.L106-.L6
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_endinit_set')
	.sect	'.debug_loc'
.L7:
	.word	-1,.L8,0,.L98-.L8
	.half	2
	.byte	138,0
	.word	0,0
.L100:
	.word	0,0
.L101:
	.word	-1,.L8,.L109-.L8,.L110-.L8
	.half	5
	.byte	144,32,157,32,0
	.word	.L110-.L8,.L99-.L8
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L102:
	.word	-1,.L8,.L111-.L8,.L112-.L8
	.half	5
	.byte	144,32,157,32,32
	.word	.L112-.L8,.L110-.L8
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_start')
	.sect	'.debug_loc'
.L13:
	.word	-1,.L14,0,.L54-.L14
	.half	2
	.byte	138,0
	.word	0,0
.L87:
	.word	-1,.L14,.L135-.L14,.L2-.L14
	.half	1
	.byte	98
	.word	.L136-.L14,.L137-.L14
	.half	5
	.byte	144,33,157,32,32
	.word	0,0
.L62:
	.word	0,0
.L92:
	.word	-1,.L14,.L131-.L14,.L54-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L84:
	.word	-1,.L14,.L134-.L14,.L133-.L14
	.half	5
	.byte	144,33,157,32,0
	.word	0,0
.L85:
	.word	-1,.L14,.L132-.L14,.L133-.L14
	.half	5
	.byte	144,32,157,32,32
	.word	0,0
.L57:
	.word	-1,.L14,.L113-.L14,.L114-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	.L16-.L14,.L115-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L90:
	.word	-1,.L14,.L129-.L14,.L130-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L137-.L14,.L133-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L89:
	.word	-1,.L14,.L137-.L14,.L2-.L14
	.half	5
	.byte	144,33,157,32,32
	.word	0,0
.L88:
	.word	-1,.L14,.L138-.L14,.L139-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L65:
	.word	-1,.L14,.L16-.L14,.L116-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L118-.L14,.L119-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L119-.L14,.L60-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L77:
	.word	-1,.L14,.L16-.L14,.L50-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L126-.L14,.L127-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L127-.L14,.L76-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L72:
	.word	-1,.L14,.L16-.L14,.L50-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L123-.L14,.L124-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L124-.L14,.L71-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L69:
	.word	-1,.L14,.L16-.L14,.L50-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L120-.L14,.L121-.L14
	.half	5
	.byte	144,32,157,32,0
	.word	.L121-.L14,.L68-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L70:
	.word	-1,.L14,.L115-.L14,.L117-.L14
	.half	5
	.byte	144,32,157,32,32
	.word	.L117-.L14,.L50-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	.L122-.L14,.L121-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L78:
	.word	-1,.L14,.L115-.L14,.L117-.L14
	.half	5
	.byte	144,32,157,32,32
	.word	.L117-.L14,.L50-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	.L128-.L14,.L127-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L73:
	.word	-1,.L14,.L115-.L14,.L117-.L14
	.half	5
	.byte	144,32,157,32,32
	.word	.L117-.L14,.L50-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	.L125-.L14,.L124-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
.L66:
	.word	-1,.L14,.L115-.L14,.L117-.L14
	.half	5
	.byte	144,32,157,32,32
	.word	.L117-.L14,.L116-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	.L114-.L14,.L119-.L14
	.half	5
	.byte	144,39,157,32,32
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L215:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,26,8,27,8,30,8,29,8,28,8,16,8,17,8,24,8,25,8,31,8,32,8,33,8,34,8,35,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('_endinit_clear')
	.sect	'.debug_frame'
	.word	24
	.word	.L215,.L6,.L93-.L6
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('_endinit_set')
	.sect	'.debug_frame'
	.word	24
	.word	.L215,.L8,.L98-.L8
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('_START')
	.sect	'.debug_frame'
	.word	12
	.word	.L215,.L10,.L103-.L10
	.sdecl	'.debug_frame',debug,cluster('__init_sp')
	.sect	'.debug_frame'
	.word	12
	.word	.L215,.L12,.L53-.L12
	.sdecl	'.debug_frame',debug,cluster('_start')
	.sect	'.debug_frame'
	.word	12
	.word	.L215,.L14,.L54-.L14
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L216:
	.word	48
	.word	-1
	.byte	3,0,2,1,30,12,26,0,8,26,8,27,8,30,8,29,8,28,8,16,8,17,8,24,8,25,8,31,8,32,8,33,8,34,8,35,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('.cocofun_1')
	.sect	'.debug_frame'
	.word	24
	.word	.L216,.L16,.L50-.L16
	.byte	8,18,8,19,8,20,8,21,8,22,8,23

; ..\cstart.c	  1078  }
; ..\cstart.c	  1079  
; ..\cstart.c	  1080  #if (  defined _REGUSERDEF16X_H || defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	  1081  /**************************************************************************
; ..\cstart.c	  1082   *
; ..\cstart.c	  1083   * FUNCTION:     safety_endinit_set
; ..\cstart.c	  1084   *
; ..\cstart.c	  1085   * DESCRIPTION:  Sets or Clears the ENDINIT bit in the WDTSCON0 register
; ..\cstart.c	  1086   *               in order to enabled or disable the write-protection for
; ..\cstart.c	  1087   *               safety-critical registers protected via the EndInit feature.
; ..\cstart.c	  1088   *
; ..\cstart.c	  1089   *************************************************************************/
; ..\cstart.c	  1090  static void inline safety_endinit_set( _endinit_t endinit_value )
; ..\cstart.c	  1091  {
; ..\cstart.c	  1092          unsigned int wdtscon0;
; ..\cstart.c	  1093  
; ..\cstart.c	  1094          /*
; ..\cstart.c	  1095           * 1st step: Password access (create password and send to WDTSCON0)
; ..\cstart.c	  1096           */
; ..\cstart.c	  1097          wdtscon0 = SCU_WDTSCON0.U;
; ..\cstart.c	  1098  
; ..\cstart.c	  1099          wdtscon0 &= 0xffffff01;         /* clear WDTLCK, WDTHPW0, WDTHPW1 */
; ..\cstart.c	  1100          wdtscon0 |= 0xf0;               /* set WDTHPW1 to 0xf */
; ..\cstart.c	  1101          wdtscon0 |= 0x1;                /* 1 must be written to ENDINIT for password access
; ..\cstart.c	  1102                                           * (but this will not actually modify the bit) */
; ..\cstart.c	  1103          SCU_WDTSCON0.U = wdtscon0;
; ..\cstart.c	  1104  
; ..\cstart.c	  1105          /*
; ..\cstart.c	  1106           * 2nd step: Modify access, set the bit ENDINIT to 1 or 0 to allow access to
; ..\cstart.c	  1107           *           registers: SCU_WDTSCON1, BTV, BIV, ISP and mod_CLC
; ..\cstart.c	  1108           */
; ..\cstart.c	  1109          wdtscon0 &= 0xfffffff0;         /* clear WDTHPW0, WDTLCK, ENDINIT  */
; ..\cstart.c	  1110          wdtscon0 |= 0x02 | endinit_value;       /* WDTHPW0=0, WDTLCK=1, ENDINIT=0 */
; ..\cstart.c	  1111          __isync();
; ..\cstart.c	  1112          SCU_WDTSCON0.U = wdtscon0;          
; ..\cstart.c	  1113          SCU_WDTSCON0.U;                 /* read is required */
; ..\cstart.c	  1114  }
; ..\cstart.c	  1115  #endif
; ..\cstart.c	  1116  
; ..\cstart.c	  1117  #if     __CLOCKS_PER_SEC_INIT
; ..\cstart.c	  1118  static void setclockpersec(void)
; ..\cstart.c	  1119  {
; ..\cstart.c	  1120          unsigned long long hz = 0;
; ..\cstart.c	  1121  
; ..\cstart.c	  1122  #if defined PLL_CLC && defined __fOSC
; ..\cstart.c	  1123  #if ( defined _REGTC11IB_H )
; ..\cstart.c	  1124  #define K       (PLL_CLC.B.PLL1_KDIV+1)
; ..\cstart.c	  1125          if ( PLL_CLC.B.PLL1_BP )                 /* PLL Bypass Operation */
; ..\cstart.c	  1126          {
; ..\cstart.c	  1127                  hz = __fOSC;
; ..\cstart.c	  1128          }
; ..\cstart.c	  1129          else
; ..\cstart.c	  1130          {
; ..\cstart.c	  1131                  if ( PLL_CLC.B.PLL1_VCOBP )         /* VCO Bypass Operation */
; ..\cstart.c	  1132                  {
; ..\cstart.c	  1133                          hz = __fOSC/K;
; ..\cstart.c	  1134                  }
; ..\cstart.c	  1135                  else                            /* PLL Operation */
; ..\cstart.c	  1136                  {
; ..\cstart.c	  1137                          hz = (16*__fOSC)/K;
; ..\cstart.c	  1138                  }
; ..\cstart.c	  1139          }
; ..\cstart.c	  1140  #endif
; ..\cstart.c	  1141  
; ..\cstart.c	  1142  #if     (  defined _REGTC1130_H || defined _REGTC1164_H \ 
; ..\cstart.c	  1143          || defined _REGTC1166_H || defined _REGTC1762_H || defined _REGTC1764_H || defined _REGTC1766_H \ 
; ..\cstart.c	  1144          || defined _REGTC1766B_H || defined _REGTC1792_H || defined _REGTC1796_H || defined _REGTC1796B_H )
; ..\cstart.c	  1145  #define P               (PLL_CLC.B.PDIV+1)
; ..\cstart.c	  1146  #define N               (PLL_CLC.B.NDIV+1)
; ..\cstart.c	  1147  #define K               (PLL_CLC.B.KDIV+1)
; ..\cstart.c	  1148  #if     ( defined _REGTC1130_H )
; ..\cstart.c	  1149  #define __SYSFS__       SYSFSL
; ..\cstart.c	  1150  #else
; ..\cstart.c	  1151  #if     (  defined _REGTC1762_H || defined _REGTC1764_H || defined _REGTC1766B_H \ 
; ..\cstart.c	  1152          || defined _REGTC1164_H || defined _REGTC1166_H )
; ..\cstart.c	  1153  #define __SYSFS__       RSV
; ..\cstart.c	  1154  #else
; ..\cstart.c	  1155  #define __SYSFS__       SYSFS
; ..\cstart.c	  1156  #endif
; ..\cstart.c	  1157  #endif
; ..\cstart.c	  1158  #define SYSCLK(CPUCLK)  (CPUCLK/(2-PLL_CLC.B.__SYSFS__))
; ..\cstart.c	  1159  #define STMCLK(CPUCLK)  (SYSCLK(CPUCLK)/STM_CLC.B.RMC)
; ..\cstart.c	  1160  #define FVCOBASE        __fOSC
; ..\cstart.c	  1161          if ( PLL_CLC.B.BYPPIN )                                                         /* Direct drive */
; ..\cstart.c	  1162          {
; ..\cstart.c	  1163                  hz = STMCLK(__fOSC);
; ..\cstart.c	  1164          }
; ..\cstart.c	  1165          else
; ..\cstart.c	  1166          {
; ..\cstart.c	  1167                  if ( PLL_CLC.B.VCOBYP )                                                 /* VCO Bypass Mode */
; ..\cstart.c	  1168                  {
; ..\cstart.c	  1169                          hz = STMCLK(__fOSC/(P*K));
; ..\cstart.c	  1170                  }
; ..\cstart.c	  1171                  else
; ..\cstart.c	  1172                  {
; ..\cstart.c	  1173                          if ( !PLL_CLC.B.OSCDISC && PLL_CLC.B.LOCK )     /* PLL Mode */
; ..\cstart.c	  1174                          {
; ..\cstart.c	  1175                                  hz = STMCLK((N*__fOSC)/(P*K));
; ..\cstart.c	  1176                          }
; ..\cstart.c	  1177                          else                                                                            /* PLL base mode */
; ..\cstart.c	  1178                          {
; ..\cstart.c	  1179                                  hz = STMCLK(FVCOBASE/K);
; ..\cstart.c	  1180                          }
; ..\cstart.c	  1181                  }
; ..\cstart.c	  1182          }
; ..\cstart.c	  1183  #endif
; ..\cstart.c	  1184  #endif
; ..\cstart.c	  1185  
; ..\cstart.c	  1186  #if defined SCU_PLLSTAT && defined __fOSC
; ..\cstart.c	  1187  #if     (  defined _REGTC1167_H || defined _REGTC1197_H || defined _REGTC1337_H || defined _REGTC1367_H \ 
; ..\cstart.c	  1188          || defined _REGTC1387_H || defined _REGTC1732_H || defined _REGTC1728_H || defined _REGTC1734_H \ 
; ..\cstart.c	  1189          || defined _REGTC1735_H || defined _REGTC1736_H || defined _REGTC1738_H || defined _REGTC1746_H \ 
; ..\cstart.c	  1190          || defined _REGTC1747_H || defined _REGTC1748_H || defined _REGTC1767_H || defined _REGTC1768_H \ 
; ..\cstart.c	  1191          || defined _REGTC1782_H || defined _REGTC1784_H || defined _REGTC1184_H || defined _REGTC1797_H \ 
; ..\cstart.c	  1192          || defined _REGTC1791_H || defined _REGTC1793_H || defined _REGTC1798_H || defined _REGTC1724_H \ 
; ..\cstart.c	  1193          || defined _REGTC2D5T_H || defined _REGTC27X_H  || defined _REGTC27XB_H || defined _REGTC26X_H \ 
; ..\cstart.c	  1194          || defined _REGTC29X_H)
; ..\cstart.c	  1195  #define P               (SCU_PLLCON0.B.PDIV+1)
; ..\cstart.c	  1196  #define N               (SCU_PLLCON0.B.NDIV+1)
; ..\cstart.c	  1197  #define K1              (SCU_PLLCON1.B.K1DIV+1)
; ..\cstart.c	  1198  #define K2              (SCU_PLLCON1.B.K2DIV+1)
; ..\cstart.c	  1199  #if     ( defined _REGTC2D5T_H )
; ..\cstart.c	  1200  #define STM_CLC_RMC     (STM0_CLC.B.RMC)
; ..\cstart.c	  1201  #else
; ..\cstart.c	  1202  #if     ( defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	  1203  #define STM_CLC_RMC     1
; ..\cstart.c	  1204  #else   
; ..\cstart.c	  1205  #define STM_CLC_RMC     (STM_CLC.B.RMC)         
; ..\cstart.c	  1206  #endif
; ..\cstart.c	  1207  #endif
; ..\cstart.c	  1208  #if     ( defined _REGTC1337_H || defined _REGTC1367_H || defined _REGTC1387_H || defined _REGTC1768_H )
; ..\cstart.c	  1209  #define SYSCLK(CPUCLK)  (CPUCLK)
; ..\cstart.c	  1210  #else
; ..\cstart.c	  1211  #if ( defined _REGTC2D5T_H )
; ..\cstart.c	  1212  #define SYSCLK(CPUCLK)  (CPUCLK/(SCU_CCUCON0.B.SPBDIV+1))
; ..\cstart.c	  1213  #else
; ..\cstart.c	  1214  #if ( defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	  1215  #define SYSCLK(CPUCLK)  (CPUCLK/SCU_CCUCON1.B.STMDIV)
; ..\cstart.c	  1216  #else
; ..\cstart.c	  1217  #define SYSCLK(CPUCLK)  (CPUCLK/(SCU_CCUCON0.B.FPIDIV+1))
; ..\cstart.c	  1218  #endif
; ..\cstart.c	  1219  #endif
; ..\cstart.c	  1220  #endif
; ..\cstart.c	  1221  #define STMCLK(CPUCLK)  (SYSCLK(CPUCLK)/STM_CLC_RMC)
; ..\cstart.c	  1222  #define FVCOBASE        __fOSC
; ..\cstart.c	  1223          if ( SCU_PLLSTAT.B.VCOBYST )    /* Prescaler mode */
; ..\cstart.c	  1224          {
; ..\cstart.c	  1225                  hz = STMCLK(__fOSC/K1);
; ..\cstart.c	  1226          }
; ..\cstart.c	  1227  #if ( defined _REGTC2D5T_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC26X_H || defined _REGTC29X_H)
; ..\cstart.c	  1228          else if ( SCU_CCUCON0.B.CLKSEL==0)
; ..\cstart.c	  1229          {
; ..\cstart.c	  1230                  hz = STMCLK(100000000);         /* back-up clock */
; ..\cstart.c	  1231          }
; ..\cstart.c	  1232  #endif
; ..\cstart.c	  1233          else
; ..\cstart.c	  1234          {
; ..\cstart.c	  1235                  if ( SCU_PLLSTAT.B.FINDIS )     /* Free running mode */
; ..\cstart.c	  1236                  {
; ..\cstart.c	  1237                          hz = STMCLK(FVCOBASE/K2);
; ..\cstart.c	  1238                  }
; ..\cstart.c	  1239                  else                                            /* Normal mode */
; ..\cstart.c	  1240                  {
; ..\cstart.c	  1241                          hz = STMCLK((N*__fOSC)/(P*K2));
; ..\cstart.c	  1242                  }
; ..\cstart.c	  1243          }
; ..\cstart.c	  1244  #endif
; ..\cstart.c	  1245  #endif
; ..\cstart.c	  1246          setfoschz ( hz );
; ..\cstart.c	  1247  }
; ..\cstart.c	  1248  #endif

	; Module end
